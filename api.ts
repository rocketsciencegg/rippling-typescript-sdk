/* tslint:disable */
/* eslint-disable */
/**
 * Rippling Platform API
 * Documentation for the Rippling Platform API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 */
export interface Address {
    /**
     * The classification of the address.
     */
    'type'?: AddressTypeEnum;
    /**
     * The formatted mailing address.
     */
    'formatted'?: string;
    /**
     * The full street address component, which may include house number, street name, P.O. box, and multi-line extended street address information, pursuant to SCIM RFC 7643 4.1.2..
     */
    'street_address'?: string;
    /**
     * The city or locality component.
     */
    'locality'?: string;
    /**
     * The state or region component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'region'?: string;
    /**
     * The zip code or postal code component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'postal_code'?: string;
    /**
     * The country component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'country'?: AddressCountryEnum;
}

export const AddressTypeEnum = {
    Home: 'HOME',
    Work: 'WORK',
    Other: 'OTHER'
} as const;

export type AddressTypeEnum = typeof AddressTypeEnum[keyof typeof AddressTypeEnum];
export const AddressCountryEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Cv: 'CV',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Sz: 'SZ',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Xk: 'XK',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    An: 'AN',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mk: 'MK',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Re: 'RE',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sy: 'SY',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Se: 'SE',
    Ch: 'CH',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type AddressCountryEnum = typeof AddressCountryEnum[keyof typeof AddressCountryEnum];

/**
 * 
 */
export interface AddressRequest {
    /**
     * The classification of the address.
     */
    'type'?: AddressRequestTypeEnum;
    /**
     * The full street address component, which may include house number, street name, P.O. box, and multi-line extended street address information, pursuant to SCIM RFC 7643 4.1.2..
     */
    'street_address'?: string;
    /**
     * The city or locality component.
     */
    'locality'?: string;
    /**
     * The state or region component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'region'?: string;
    /**
     * The zip code or postal code component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'postal_code'?: string;
    /**
     * The country component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'country'?: AddressRequestCountryEnum;
}

export const AddressRequestTypeEnum = {
    Home: 'HOME',
    Work: 'WORK',
    Other: 'OTHER'
} as const;

export type AddressRequestTypeEnum = typeof AddressRequestTypeEnum[keyof typeof AddressRequestTypeEnum];
export const AddressRequestCountryEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Cv: 'CV',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Sz: 'SZ',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Xk: 'XK',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    An: 'AN',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mk: 'MK',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Re: 'RE',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sy: 'SY',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Se: 'SE',
    Ch: 'CH',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type AddressRequestCountryEnum = typeof AddressRequestCountryEnum[keyof typeof AddressRequestCountryEnum];

/**
 * 
 */
export interface Application {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Application status
     */
    'status'?: ApplicationStatusEnum;
    /**
     * Application stage
     */
    'stage'?: string;
    /**
     * Application creation date
     */
    'applied_at'?: string;
    /**
     * Job requisition ID
     */
    'job_id'?: string;
    /**
     * Job requisition  Expandable field
     */
    'job'?: JobRequisition;
    /**
     * Application url
     */
    'url'?: string;
}

export const ApplicationStatusEnum = {
    Active: 'ACTIVE',
    Rejected: 'REJECTED',
    Hired: 'HIRED',
    Archived: 'ARCHIVED'
} as const;

export type ApplicationStatusEnum = typeof ApplicationStatusEnum[keyof typeof ApplicationStatusEnum];

/**
 * 
 */
export interface AttributeChange {
    /**
     * The name of attribute changed.
     */
    'attribute_name'?: string;
    /**
     * Old value of attribute, before the change.
     */
    'old_attribute_value'?: object;
    /**
     * New value of attribute, after the change
     */
    'new_attribute_value'?: object;
}
/**
 * 
 */
export interface AttributeChangeDetails {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * The time the change was requested by worker
     */
    'created_at'?: string;
    /**
     * The time the change was applied
     */
    'updated_at'?: string;
    /**
     * List of attributes that were modified as part of the change.
     */
    'attribute_changes'?: Array<AttributeChange>;
    /**
     * Identifier of worker who made the change
     */
    'changed_by_worker_id'?: string;
    /**
     * Worker who made the change  Expandable field
     */
    'changed_by_worker'?: Worker;
    /**
     * Reason provided by worker for making the change
     */
    'reason'?: string;
    /**
     * The time the change was scheduled to take effect on
     */
    'effective_from_date'?: string;
}
/**
 * 
 */
export interface Break {
    /**
     * The start time of the break.
     */
    'start_time'?: string;
    /**
     * The end time of the break.
     */
    'end_time'?: string;
    /**
     * The original start time of the break. If the startTime field has been rounded then this contain the start time before the rounding occured.
     */
    'original_start_time'?: string;
    /**
     * The original end time of the break. If the endTime field has been rounded then this contain the end time before the rounding occured.
     */
    'original_end_time'?: string;
    /**
     * The ID of the break type.
     */
    'break_type_id'?: string;
}
/**
 * 
 */
export interface BreakRequest {
    /**
     * The start time of the break.
     */
    'start_time'?: string;
    /**
     * The end time of the break.
     */
    'end_time'?: string;
    /**
     * The ID of the break type.
     */
    'break_type_id'?: string;
}
export interface BulkCreateCustomObjectsCustomObjectApiNameRecords200Response {
    'data'?: Array<CustomObjectDataRow>;
}
export interface BulkCreateCustomObjectsCustomObjectApiNameRecordsRequest {
    'rows_to_write'?: Array<{ [key: string]: any; }>;
    'all_or_nothing'?: boolean;
}
export interface BulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest {
    /**
     * a list of ids, e.g. [id_1, id_2].
     */
    'rows_to_delete'?: Array<string>;
    'all_or_nothing'?: boolean;
}
/**
 * 
 */
export interface BulkDraftHireRequest {
    /**
     * List of draft hires
     */
    'draft_hires': Array<DraftHire>;
}
export interface BulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest {
    'rows_to_update'?: Array<{ [key: string]: any; }>;
    'all_or_nothing'?: boolean;
}
/**
 * 
 */
export interface BusinessPartner {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Identifier of business partner group the business parter is a part of
     */
    'business_partner_group_id': string;
    /**
     * Business partner group the business partner is a part of  Expandable field
     */
    'business_partner_group'?: BusinessPartnerGroup;
    /**
     * Identifier of worker who is the business partner
     */
    'worker_id': string;
    /**
     * Worker who is the business partner  Expandable field
     */
    'worker'?: Worker;
    /**
     * Identifier of group of workers associated with the business partner
     */
    'client_group_id'?: string;
    /**
     * Group of workers associated with the business partner  Expandable field
     */
    'client_group'?: Supergroup;
    /**
     * Number of workers associated with the business partner
     */
    'client_group_member_count'?: number;
}
/**
 * 
 */
export interface BusinessPartnerGroup {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Name used to identify business partner group
     */
    'name': string;
    /**
     * Type of business partner group
     */
    'domain'?: BusinessPartnerGroupDomainEnum;
    /**
     * Id of Optional default business partner worker to whom all employees will be mapped if not explicitly mapped to a business partner in the group.
     */
    'default_business_partner_id'?: string;
    /**
     * Optional default business partner worker to whom all employees will be mapped if not explicitly mapped to a business partner in the group.  Expandable field
     */
    'default_business_partner'?: Worker;
}

export const BusinessPartnerGroupDomainEnum = {
    Hr: 'HR',
    It: 'IT',
    Finance: 'FINANCE',
    Recruiting: 'RECRUITING',
    Other: 'OTHER'
} as const;

export type BusinessPartnerGroupDomainEnum = typeof BusinessPartnerGroupDomainEnum[keyof typeof BusinessPartnerGroupDomainEnum];

/**
 * 
 */
export interface BusinessPartnerGroupRequest {
    /**
     * Name used to identify business partner group
     */
    'name': string;
    /**
     * Type of business partner group
     */
    'domain'?: BusinessPartnerGroupRequestDomainEnum;
    /**
     * Id of Optional default business partner worker to whom all employees will be mapped if not explicitly mapped to a business partner in the group.
     */
    'default_business_partner_id'?: string;
}

export const BusinessPartnerGroupRequestDomainEnum = {
    Hr: 'HR',
    It: 'IT',
    Finance: 'FINANCE',
    Recruiting: 'RECRUITING',
    Other: 'OTHER'
} as const;

export type BusinessPartnerGroupRequestDomainEnum = typeof BusinessPartnerGroupRequestDomainEnum[keyof typeof BusinessPartnerGroupRequestDomainEnum];

/**
 * 
 */
export interface BusinessPartnerRequest {
    /**
     * Identifier of business partner group the business parter is a part of
     */
    'business_partner_group_id': string;
    /**
     * Identifier of worker who is the business partner
     */
    'worker_id': string;
}
/**
 * 
 */
export interface CanadaFields {
    /**
     * Social Insurance Number (SIN) for Canada employees.
     */
    'sin'?: string;
}
/**
 * 
 */
export interface Candidate {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Candidate first name
     */
    'first_name'?: string;
    /**
     * Candidate last name
     */
    'last_name'?: string;
    /**
     * Candidate email
     */
    'email'?: string;
    /**
     * Candidate phone number
     */
    'phone_number'?: string;
    /**
     * Candidate timezone
     */
    'timezone'?: string;
}
/**
 * 
 */
export interface Company {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The company\'s ultimate holding entity.
     */
    'parent_legal_entity_id'?: string;
    /**
     * The company\'s ultimate holding entity.  Expandable field
     */
    'parent_legal_entity'?: LegalEntity;
    /**
     * A list of the company\'s entities.
     */
    'legal_entities_id': Array<string>;
    /**
     * A list of the company\'s entities.  Expandable field
     */
    'legal_entities': Array<LegalEntity>;
    /**
     * The physical address of the holding entity.
     */
    'physical_address'?: Address;
    /**
     * The email address used when registering this company.
     */
    'primary_email'?: string;
    /**
     * The legal name of the company.
     */
    'legal_name'?: string;
    /**
     * The doing business as name for the company.
     */
    'doing_business_as_name'?: string;
    /**
     * The phone number for the company.
     */
    'phone'?: string;
    /**
     * The name of the company.
     */
    'name': string;
}
/**
 * 
 */
export interface CompanyEmploymentType {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The display label of the employment type.
     */
    'label': string;
    /**
     * The name of the employment type for non-custom employment types.
     */
    'name'?: string;
    /**
     * The classification of the worker by the company. * `CONTRACTOR`: Contractors are self-employed workers who provide services on a short-term or per-project basis and are not eligible for tax-withholding or benefits. * `EMPLOYEE`: Employees are hired and managed by an employer, work under the employer\'s direct supervision and control, and are protected by law for wages and employment rights.
     */
    'type'?: CompanyEmploymentTypeTypeEnum;
    /**
     * The compensation period for the employment type. * `SALARIED`: Employees that are paid a fixed amount per year. * `HOURLY`: Employees that are paid a wage per hour worked.
     */
    'compensation_time_period'?: CompanyEmploymentTypeCompensationTimePeriodEnum;
    /**
     * The amount worked for the employment type. * `FULL-TIME`: Full-time is at least 30 hours per week. Full-time workers will typically be eligible for benefits. * `PART-TIME`: Part-time is less than 30 hours per week. These workers may be eligible for benefits, depending on company settings and hours worked. * `TEMPORARY`: These workers are hired on a temporary basis. You can specify how each worker with this employment type will be paid individually.
     */
    'amount_worked'?: CompanyEmploymentTypeAmountWorkedEnum;
}

export const CompanyEmploymentTypeTypeEnum = {
    Contractor: 'CONTRACTOR',
    Employee: 'EMPLOYEE'
} as const;

export type CompanyEmploymentTypeTypeEnum = typeof CompanyEmploymentTypeTypeEnum[keyof typeof CompanyEmploymentTypeTypeEnum];
export const CompanyEmploymentTypeCompensationTimePeriodEnum = {
    Hourly: 'HOURLY',
    Salaried: 'SALARIED'
} as const;

export type CompanyEmploymentTypeCompensationTimePeriodEnum = typeof CompanyEmploymentTypeCompensationTimePeriodEnum[keyof typeof CompanyEmploymentTypeCompensationTimePeriodEnum];
export const CompanyEmploymentTypeAmountWorkedEnum = {
    PartTime: 'PART-TIME',
    FullTime: 'FULL-TIME',
    Temporary: 'TEMPORARY'
} as const;

export type CompanyEmploymentTypeAmountWorkedEnum = typeof CompanyEmploymentTypeAmountWorkedEnum[keyof typeof CompanyEmploymentTypeAmountWorkedEnum];

/**
 * 
 */
export interface Compensation {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The worker\'s ID.
     */
    'worker_id'?: string;
    /**
     * The worker\'s details.  Expandable field
     */
    'worker'?: Worker;
    /**
     * The worker\'s annual compensation. This calculation assumes 40-hour work weeks for workers with an hourly wage.
     */
    'annual_compensation'?: Currency;
    /**
     * The worker\'s annual salary equivalent, for insurance purposes. It will be equal to the worker\'s annual compensation, except for owners that are receiving no cashcompensation.
     */
    'annual_salary_equivalent'?: Currency;
    /**
     * The worker\'s hourly wage. This calculation assumes 40-hour work weeks for workers with fixed compensation.
     */
    'hourly_wage'?: Currency;
    /**
     * The worker\'s monthly compensation. This calculation assumes 40-hour work weeks for workers with an hourly wage.
     */
    'monthly_compensation'?: Currency;
    /**
     * The worker\'s on-target commission.
     */
    'on_target_commission'?: Currency;
    /**
     * The worker\'s hourly wage. This calculation assumes 40-hour work weeks for workers with fixed compensation.
     */
    'relocation_reimbursement'?: Currency;
    /**
     * The worker\'s signing bonus.
     */
    'signing_bonus'?: Currency;
    /**
     * The worker\'s target annual bonus amount.
     */
    'target_annual_bonus'?: Currency;
    /**
     * The worker\'s weekly compensation. This calculation assumes 40-hour work weeks for workers with an hourly wage.
     */
    'weekly_compensation'?: Currency;
    /**
     * The worker\'s target annual bonus as a percent of annual compensation.
     */
    'target_annual_bonus_percent'?: number;
    /**
     * The worker\'s bonus schedule.
     */
    'bonus_schedule'?: string;
    /**
     * The payment type for an worker\'s compensation.
     */
    'payment_type'?: string;
    /**
     * The payment terms for an worker\'s compensation.
     */
    'payment_terms'?: string;
    /**
     * Salary effective date
     */
    'salary_effective_date'?: string;
}
/**
 * 
 */
export interface Country {
    /**
     * The code of the country.
     */
    'code': CountryCodeEnum;
}

export const CountryCodeEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Cv: 'CV',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Sz: 'SZ',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Xk: 'XK',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    An: 'AN',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mk: 'MK',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Re: 'RE',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sy: 'SY',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Se: 'SE',
    Ch: 'CH',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type CountryCodeEnum = typeof CountryCodeEnum[keyof typeof CountryCodeEnum];

/**
 * 
 */
export interface CountryFields {
    /**
     * Country-wise regional fields for USA
     */
    'us'?: USFields;
    /**
     * Country-wise regional fields for Canada
     */
    'ca'?: CanadaFields;
}
/**
 * Response model for bulk draft hire creation.
 */
export interface CreateBulkDraftHireResponse {
    /**
     * List of invalid draft hire requests
     */
    'invalid_items'?: Array<DraftHireResult>;
    /**
     * Detailed results for each draft hire item
     */
    'successful_results'?: Array<DraftHireResult>;
}
export interface CreateCustomObjectsCustomObjectApiNameFieldsRequest {
    'name'?: string;
    'description'?: string;
    'data_type'?: object;
    'required'?: boolean;
    'rql_definition'?: object;
    'is_unique'?: boolean;
    'formula_attr_metas'?: object;
    'section'?: object;
    'enable_history'?: boolean;
    'derived_field_formula'?: string;
    'derived_aggregated_field'?: object;
}
export interface CreateCustomObjectsCustomObjectApiNameRecords200Response {
    'data'?: CustomObjectDataRow;
}
export interface CreateCustomObjectsRequest {
    'name'?: string;
    'description'?: string;
    'category'?: string;
}
export interface CreateObjectCategoriesRequest {
    'name'?: string;
    'description'?: string;
}
/**
 * 
 */
export interface Currency {
    /**
     * The currency type, ex: USD, EUR, etc.
     */
    'currency_type'?: string;
    /**
     * The decimal amount for the currency.
     */
    'value'?: number;
}
/**
 * 
 */
export interface CustomField {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the custom field.
     */
    'name': string;
    /**
     * The description of the custom field.
     */
    'description'?: string;
    /**
     * Whether the custom field is required.
     */
    'required'?: boolean;
    /**
     * The data type of the custom field.
     */
    'type': CustomFieldTypeEnum;
}

export const CustomFieldTypeEnum = {
    Text: 'TEXT',
    Date: 'DATE',
    Number: 'NUMBER',
    Currency: 'CURRENCY',
    Percentage: 'PERCENTAGE',
    Select: 'SELECT',
    File: 'FILE',
    Id: 'ID',
    Radio: 'RADIO',
    Textarea: 'TEXTAREA',
    Range: 'RANGE',
    ReferenceId: 'REFERENCE_ID',
    Boolean: 'BOOLEAN',
    Address: 'ADDRESS',
    OgReferenceField: 'OG_REFERENCE_FIELD',
    NativeEdge: 'NATIVE_EDGE',
    Datetime: 'DATETIME',
    Email: 'EMAIL',
    Url: 'URL'
} as const;

export type CustomFieldTypeEnum = typeof CustomFieldTypeEnum[keyof typeof CustomFieldTypeEnum];

/**
 * Custom field information for a draft hire.      Custom fields are associated with RoleWithCompany model.     
 */
export interface CustomFieldInfo {
    /**
     * Name of the custom field
     */
    'field_name': string;
    /**
     * Value of the custom field
     */
    'field_value': object;
}
/**
 * 
 */
export interface CustomLocation {
    /**
     * The address of the custom location.
     */
    'address': Address;
}
/**
 * 
 */
export interface CustomLocationRequest {
    /**
     * The address of the custom location.
     */
    'address': AddressRequest;
}
/**
 * 
 */
export interface CustomObject {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the custom object
     */
    'name': string;
    /**
     * The description of the custom object
     */
    'description'?: string;
    /**
     * The api name of the custom object
     */
    'api_name'?: string;
    /**
     * The plural label of the custom object
     */
    'plural_label': string;
    /**
     * The category of the custom object
     */
    'category_id': string;
    /**
     * The native category of the custom object if belongs to
     */
    'native_category_id'?: string;
    /**
     * The id of the package which the custom object belongs to
     */
    'managed_package_install_id'?: string;
    /**
     * Whether to record the history of the custom object
     */
    'enable_history': boolean;
    /**
     * The id of the owner for the custom object
     */
    'owner_id'?: string;
}
/**
 * 
 */
export interface CustomObjectDataRow {
    [key: string]: any;

    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the custom object datarow
     */
    'name': string;
    /**
     * The external id of the custom object datarow
     */
    'external_id'?: string;
    'created_by'?: CustomObjectDataRowCreatedBy;
    'last_modified_by'?: CustomObjectDataRowCreatedBy;
    'owner_role'?: CustomObjectDataRowCreatedBy;
    'system_updated_at'?: string;
}
export interface CustomObjectDataRowCreatedBy {
    'id'?: string;
    'display_value'?: string;
    'image'?: string;
}
/**
 * 
 */
export interface CustomObjectField {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the custom object field
     */
    'name': string;
    /**
     * The custom object which the field belongs to
     */
    'custom_object': string;
    /**
     * The description of the custom object field
     */
    'description'?: string;
    /**
     * The api name of the custom object field
     */
    'api_name': string;
    /**
     * The field type
     */
    'data_type': object;
    /**
     * This field specifies whether a particular column value has unique values
     */
    'is_unique': boolean;
    /**
     * whether the field is imuatable
     */
    'is_immutable': boolean;
    /**
     * whether the field is standard field
     */
    'is_standard': boolean;
    /**
     * The id of the package which the custom object field belongs to
     */
    'managed_package_install_id'?: string;
    /**
     * whether the history is enable for the field
     */
    'enable_history': boolean;
}
/**
 * 
 */
export interface DayOff {
    /**
     * The date of the day off.
     */
    'date': string;
    /**
     * The number of minutes taken off for the day.
     */
    'number_of_minutes_taken_off': number;
}
/**
 * 
 */
export interface Department {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the department.
     */
    'name': string;
    /**
     * The parent department.
     */
    'parent_id'?: string;
    /**
     * The parent department.  Expandable field
     */
    'parent'?: Department;
    /**
     * Reference code of the department.
     */
    'reference_code'?: string;
    /**
     * The identifier of departments in the department hierarchy ordered from parent department to child department.
     */
    'department_hierarchy_id'?: Array<string>;
    /**
     * List of departments in the department hierarchy. Refer department_hierarchy_ids for department hierarchy order.  Expandable field
     */
    'department_hierarchy'?: Array<Department>;
}
/**
 *      A draft hire represents a candidate who has been offered a position but hasn\'t started yet.      This class provides Platform API access to draft hire data stored as RoleWithCompany instances     in a candidate state, allowing external systems to create and manage draft hires.     
 */
export interface DraftHire {
    /**
     * Personal information for the draft hire candidate
     */
    'personal_info': PersonalInfo;
    /**
     * Employment information for the draft hire position
     */
    'employment_info': EmploymentInfo;
    /**
     * Work location information
     */
    'work_location_info': WorkLocationInfo;
    /**
     * Custom fields for the draft hire
     */
    'custom_fields'?: Array<CustomFieldInfo>;
    /**
     * External reference ID for tracking purposes
     */
    'reference_id': string;
}
/**
 * Result for an individual draft hire creation.
 */
export interface DraftHireResult {
    /**
     * External reference ID from the request
     */
    'reference_id': string;
    /**
     * Generated draft hire ID if successful
     */
    'draft_hire_id'?: string;
    /**
     * Status of the creation (success, error, warning)
     */
    'status': string;
    /**
     * Success or error message
     */
    'message'?: string;
    /**
     * List of validation errors if any
     */
    'errors'?: Array<string>;
}
/**
 * 
 */
export interface Email {
    /**
     * A valid email address.
     */
    'value'?: string;
    /**
     * The classification of the email.
     */
    'type'?: EmailTypeEnum;
    /**
     * The display value of the email address.
     */
    'display'?: string;
}

export const EmailTypeEnum = {
    Home: 'HOME',
    Work: 'WORK',
    Other: 'OTHER'
} as const;

export type EmailTypeEnum = typeof EmailTypeEnum[keyof typeof EmailTypeEnum];

/**
 * Employment information for a draft hire.
 */
export interface EmploymentInfo {
    /**
     * Manager ID
     */
    'manager_id'?: string;
    /**
     * Start date
     */
    'start_date'?: string;
    /**
     * Work email
     */
    'work_email'?: string;
    /**
     * Employment type ID
     */
    'employment_type_id': string;
    /**
     * Legal entity ID
     */
    'legal_entity_id'?: string;
    /**
     * Overtime exemption
     */
    'overtime_exemption'?: EmploymentInfoOvertimeExemptionEnum;
    /**
     * Department ID
     */
    'department_id'?: string;
    /**
     * Teams IDs
     */
    'teams_ids'?: Array<string>;
    /**
     * Title
     */
    'title'?: string;
    /**
     * Level ID
     */
    'level_id'?: string;
    /**
     * Job title
     */
    'job_title'?: string;
    /**
     * Probation end date
     */
    'probation_end_date'?: string;
    /**
     * Contract end date
     */
    'contract_end_date'?: string;
    /**
     * Salary per unit
     */
    'salary_per_unit'?: number;
    /**
     * Salary unit
     */
    'salary_unit'?: string;
    /**
     * Currency
     */
    'currency'?: string;
    /**
     * Signing bonus
     */
    'signing_bonus'?: number;
    /**
     * Relocation reimbursement
     */
    'relocation_reimbursement'?: number;
    /**
     * Target annual bonus
     */
    'target_annual_bonus'?: number;
    /**
     * On target commission
     */
    'on_target_commission'?: number;
    /**
     * Weekly hours
     */
    'weekly_hours'?: number;
    /**
     * Duties
     */
    'duties'?: string;
    /**
     * Equity number of shares
     */
    'equity_num_shares'?: number;
    /**
     * Equity value
     */
    'equity_value'?: number;
    /**
     * Offer expiration date
     */
    'offer_expiration_date'?: string;
    'equity_vesting_schedule'?: EquityVestingSchedule;
}

export const EmploymentInfoOvertimeExemptionEnum = {
    Exempt: 'exempt',
    NonExempt: 'non-exempt'
} as const;

export type EmploymentInfoOvertimeExemptionEnum = typeof EmploymentInfoOvertimeExemptionEnum[keyof typeof EmploymentInfoOvertimeExemptionEnum];

/**
 * 
 */
export interface EntitlementModel {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Description of the entitlement
     */
    'description': string;
    /**
     * Display name of the entitlement
     */
    'display_name': string;
}
/**
 * Equity vesting schedule configuration with vesting terms and percentages.
 */
export interface EquityVestingSchedule {
    /**
     * Required company ID for the vesting schedule
     */
    'company_id': string;
    /**
     * Name of the vesting schedule
     */
    '_name'?: string;
    /**
     * Spoke ID for the vesting schedule
     */
    'spokeId'?: string;
    /**
     * Type of vesting schedule
     */
    'vestingType'?: string;
    /**
     * Total number of vesting months
     */
    'totalVestingMonths'?: number;
    /**
     * Total number of vesting years
     */
    'totalVestingYears'?: number;
    /**
     * Number of cliff months before vesting begins
     */
    'cliffMonths'?: number;
    /**
     * Number of continuous vesting months
     */
    'continuousVestingMonths'?: number;
    /**
     * Percentage of initial vesting as decimal
     */
    'percentageInitialVesting'?: number;
}
/**
 * 
 */
export interface Function {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The function name
     */
    'name'?: string;
    /**
     * The API name of the function
     */
    'api_name'?: string;
    /**
     * The function description
     */
    'description'?: string;
    /**
     * The current draft of code for the function
     */
    'code_draft'?: string;
    /**
     * The dependencies of the function
     */
    'dependencies'?: object;
}
/**
 * 
 */
export interface FunctionDeployment {
    /**
     * The ID of the deployment
     */
    'id': string;
    /**
     * The external ID of the deployment
     */
    'external_id'?: string;
    /**
     * The ID of the function that this deployment is associated with
     */
    'function_id'?: string;
    /**
     * The API name of the function that this deployment is associated with
     */
    'function_api_name'?: string;
    /**
     * The ID of the version that this deployment is associated with
     */
    'function_version_id'?: string;
    /**
     * The human friendly ID of version that this deployment is associated with
     */
    'function_version_human_friendly_id'?: number;
    /**
     * The code for the deployment
     */
    'code'?: string;
    /**
     * The dependencies of the deployment
     */
    'dependencies'?: object;
    /**
     * Domains that function runs from this deployment are allowed to access
     */
    'allowed_domains'?: Array<string>;
    /**
     * The runtime for the deployment
     */
    'runtime'?: string;
    /**
     * Additional, runtime-specific options for the deployment
     */
    'options'?: object;
    /**
     * The status of the deployment
     */
    'status'?: string;
    /**
     * The creation date of the deployment
     */
    'created_at': string;
    /**
     * The last updated date of the deployment
     */
    'updated_at': string;
}
/**
 * 
 */
export interface FunctionDeploymentLog {
    /**
     * The log message
     */
    'message': string;
    /**
     * The sequence number of the log line
     */
    'sequence_num': number;
    /**
     * The log timestamp
     */
    'timestamp'?: string;
    /**
     * The log level
     */
    'level'?: string;
    /**
     * Parameters associated with the log line
     */
    'params'?: object;
}
/**
 * 
 */
export interface FunctionDevBundle {
    /**
     * The bundle contents as a base64 encoded zip
     */
    'contents'?: string;
}
/**
 * 
 */
export interface FunctionExecution {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID of the function this execution belongs to
     */
    'function_id': string;
    /**
     * The inputs of the execution
     */
    'inputs': object;
    /**
     * The outputs of the execution
     */
    'outputs'?: object;
    /**
     * The status of the execution
     */
    'status'?: string;
    /**
     * The start time of the execution
     */
    'started_at'?: string;
    /**
     * The end time of the execution
     */
    'finished_at'?: string;
}
/**
 * 
 */
export interface FunctionExecutionLog {
    /**
     * The log message
     */
    'message': string;
    /**
     * The sequence number of the log line
     */
    'sequence_num': number;
    /**
     * The log timestamp
     */
    'timestamp'?: string;
    /**
     * The log level
     */
    'level'?: string;
    /**
     * Parameters associated with the log line
     */
    'params'?: object;
}
export interface GetBusinessPartnerGroups200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Name used to identify business partner group
     */
    'name': string;
    /**
     * Type of business partner group
     */
    'domain'?: GetBusinessPartnerGroups200ResponseDomainEnum;
    /**
     * Id of Optional default business partner worker to whom all employees will be mapped if not explicitly mapped to a business partner in the group.
     */
    'default_business_partner_id'?: string;
    /**
     * Optional default business partner worker to whom all employees will be mapped if not explicitly mapped to a business partner in the group.  Expandable field
     */
    'default_business_partner'?: Worker;
}

export const GetBusinessPartnerGroups200ResponseDomainEnum = {
    Hr: 'HR',
    It: 'IT',
    Finance: 'FINANCE',
    Recruiting: 'RECRUITING',
    Other: 'OTHER'
} as const;

export type GetBusinessPartnerGroups200ResponseDomainEnum = typeof GetBusinessPartnerGroups200ResponseDomainEnum[keyof typeof GetBusinessPartnerGroups200ResponseDomainEnum];

export interface GetBusinessPartners200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Identifier of business partner group the business parter is a part of
     */
    'business_partner_group_id': string;
    /**
     * Business partner group the business partner is a part of  Expandable field
     */
    'business_partner_group'?: BusinessPartnerGroup;
    /**
     * Identifier of worker who is the business partner
     */
    'worker_id': string;
    /**
     * Worker who is the business partner  Expandable field
     */
    'worker'?: Worker;
    /**
     * Identifier of group of workers associated with the business partner
     */
    'client_group_id'?: string;
    /**
     * Group of workers associated with the business partner  Expandable field
     */
    'client_group'?: Supergroup;
    /**
     * Number of workers associated with the business partner
     */
    'client_group_member_count'?: number;
}
export interface GetDepartments200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the department.
     */
    'name': string;
    /**
     * The parent department.
     */
    'parent_id'?: string;
    /**
     * The parent department.  Expandable field
     */
    'parent'?: Department;
    /**
     * Reference code of the department.
     */
    'reference_code'?: string;
    /**
     * The identifier of departments in the department hierarchy ordered from parent department to child department.
     */
    'department_hierarchy_id'?: Array<string>;
    /**
     * List of departments in the department hierarchy. Refer department_hierarchy_ids for department hierarchy order.  Expandable field
     */
    'department_hierarchy'?: Array<Department>;
}
export interface GetEmploymentTypes200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The display label of the employment type.
     */
    'label': string;
    /**
     * The name of the employment type for non-custom employment types.
     */
    'name'?: string;
    /**
     * The classification of the worker by the company. * `CONTRACTOR`: Contractors are self-employed workers who provide services on a short-term or per-project basis and are not eligible for tax-withholding or benefits. * `EMPLOYEE`: Employees are hired and managed by an employer, work under the employer\'s direct supervision and control, and are protected by law for wages and employment rights.
     */
    'type'?: GetEmploymentTypes200ResponseTypeEnum;
    /**
     * The compensation period for the employment type. * `SALARIED`: Employees that are paid a fixed amount per year. * `HOURLY`: Employees that are paid a wage per hour worked.
     */
    'compensation_time_period'?: GetEmploymentTypes200ResponseCompensationTimePeriodEnum;
    /**
     * The amount worked for the employment type. * `FULL-TIME`: Full-time is at least 30 hours per week. Full-time workers will typically be eligible for benefits. * `PART-TIME`: Part-time is less than 30 hours per week. These workers may be eligible for benefits, depending on company settings and hours worked. * `TEMPORARY`: These workers are hired on a temporary basis. You can specify how each worker with this employment type will be paid individually.
     */
    'amount_worked'?: GetEmploymentTypes200ResponseAmountWorkedEnum;
}

export const GetEmploymentTypes200ResponseTypeEnum = {
    Contractor: 'CONTRACTOR',
    Employee: 'EMPLOYEE'
} as const;

export type GetEmploymentTypes200ResponseTypeEnum = typeof GetEmploymentTypes200ResponseTypeEnum[keyof typeof GetEmploymentTypes200ResponseTypeEnum];
export const GetEmploymentTypes200ResponseCompensationTimePeriodEnum = {
    Hourly: 'HOURLY',
    Salaried: 'SALARIED'
} as const;

export type GetEmploymentTypes200ResponseCompensationTimePeriodEnum = typeof GetEmploymentTypes200ResponseCompensationTimePeriodEnum[keyof typeof GetEmploymentTypes200ResponseCompensationTimePeriodEnum];
export const GetEmploymentTypes200ResponseAmountWorkedEnum = {
    PartTime: 'PART-TIME',
    FullTime: 'FULL-TIME',
    Temporary: 'TEMPORARY'
} as const;

export type GetEmploymentTypes200ResponseAmountWorkedEnum = typeof GetEmploymentTypes200ResponseAmountWorkedEnum[keyof typeof GetEmploymentTypes200ResponseAmountWorkedEnum];

export interface GetJobFunctions200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Displayed name of the job function
     */
    'name'?: string;
}
export interface GetLeaveAccruals200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID of the worker for whom the accrual is for
     */
    'worker_id': string;
    /**
     * The worker for whom the accrual is for  Expandable field
     */
    'worker'?: Worker;
    /**
     * The ID of the worker who granted this accrual. This is typically the Time Off admin.
     */
    'grantor_id': string;
    /**
     * The worker who granted this accrual. This is typically the Time Off admin.  Expandable field
     */
    'grantor'?: Worker;
    /**
     * The company leave type ID associated with this accrual
     */
    'leave_type_id': string;
    /**
     * The date when this accrual becomes effective
     */
    'accrual_date': string;
    /**
     * The number of hours accrued. It can be negative for deductions. This is applicable if the policy tracks in hours.
     */
    'num_hours'?: number;
    /**
     * The number of days accrued. It can be negative for deductions. This is applicable if the policy tracks in days.
     */
    'num_days'?: number;
    /**
     * The monetary value of this accrual (for policies with monetary tracking)
     */
    'monetary_amount_accrued'?: number;
    /**
     * The date when this accrual expires (if applicable)
     */
    'expiration_date'?: string;
    /**
     * The comment for this accrual. This is required if the leave policy requires a comment on accruals.
     */
    'comment'?: string;
}
export interface GetSupergroups200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The group\'s display name.
     */
    'display_name'?: string;
    /**
     * The group\'s name.
     */
    'name'?: string;
    /**
     * The id of the group\'s app owner.
     */
    'app_owner_id'?: string;
    /**
     * The group type
     */
    'group_type'?: string;
    /**
     * The sub group type
     */
    'sub_group_type'?: string;
    /**
     * Whether the group is read only.
     */
    'read_only'?: boolean;
    /**
     * The group\'s description.
     */
    'description'?: string;
    /**
     * The group\'s parent.
     */
    'parent'?: string;
    /**
     * The group\'s mutually exclusive key
     */
    'mutually_exclusive_key'?: string;
    /**
     * Whether the group is the cumulatively exhaustive default
     */
    'cumulatively_exhaustive_default'?: boolean;
    /**
     * Whether the group include terminated roles
     */
    'include_terminated'?: boolean;
    /**
     * Whether the group allows non employees
     */
    'allow_non_employees'?: boolean;
    /**
     * Whether the group can override role states
     */
    'can_override_role_states'?: boolean;
    /**
     * The group\'s priority when calculating mutual exclusivity
     */
    'priority'?: number;
    /**
     * Whether the group is invisible
     */
    'is_invisible'?: boolean;
    /**
     * Whether to ignore provisioning group matching when determining group membership
     */
    'ignore_prov_group_matching'?: boolean;
}
export interface GetTeams200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The parent team
     */
    'parent_id'?: string;
    /**
     * The parent team  Expandable field
     */
    'parent'?: Team;
    /**
     * The name of the team.
     */
    'name': string;
}
export interface GetUsers200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Whether the user is able to access company resources, typically when they are in actively engaged with the company and not after off-boarding.
     */
    'active'?: boolean;
    /**
     * The unique identifier across Rippling used by the User for direct authentication into their associated company. Globally unique.
     */
    'username'?: string;
    /**
     * The user\'s name.
     */
    'name'?: UserName;
    /**
     * The display name of the user using either the concatenated preferred given and family name or username depending on availability.
     */
    'display_name'?: string;
    /**
     * The user\'s email addresses.
     */
    'emails'?: Array<Email>;
    /**
     * The user\'s phone numbers.
     */
    'phone_numbers'?: Array<UserPhoneNumber>;
    /**
     * The user\'s addresses.
     */
    'addresses'?: Array<UserAddress>;
    /**
     * The user\'s photos.
     */
    'photos'?: Array<UserPhoto>;
    /**
     * The User\'s preferred written or spoken language in the same format of the HTTP Accept-Language header, pursuant to Section 5.3.5 of RFC7231.
     */
    'preferred_language'?: string;
    /**
     * The User\'s default location for purposes of localization of currency, date time format, or numerical representations pursuant to RFC5646.
     */
    'locale'?: string;
    /**
     * The User\'s current time zone in IANA database Olson format
     */
    'timezone'?: string;
    /**
     * The permanent profile number of the user.
     */
    'number'?: string;
}
export interface GetWorkLocations200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the work location.
     */
    'name': string;
    /**
     * The address for the work location.
     */
    'address': Address;
}
export interface GetWorkers200Response {
    '__meta'?: MetaResponseMeta;
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The worker\'s associated user.
     */
    'user_id'?: string;
    /**
     * The worker\'s associated user.  Expandable field
     */
    'user'?: User;
    /**
     * Whether the worker is a manager
     */
    'is_manager'?: boolean;
    /**
     * The worker\'s manager.
     */
    'manager_id'?: string;
    /**
     * The worker\'s manager.  Expandable field
     */
    'manager'?: Worker;
    /**
     * The worker\'s associated legal entity.
     */
    'legal_entity_id'?: string;
    /**
     * The worker\'s associated legal entity.  Expandable field
     */
    'legal_entity'?: LegalEntity;
    /**
     * The worker\'s country.
     */
    'country'?: GetWorkers200ResponseCountryEnum;
    /**
     * The start date of the worker.
     */
    'start_date'?: string;
    /**
     * The end date of the worker.
     */
    'end_date'?: string;
    /**
     * The worker\'s number within the organization.
     */
    'number'?: number;
    /**
     * The worker\'s associated work email address.
     */
    'work_email'?: string;
    /**
     * The worker\'s associated personal email address.
     */
    'personal_email'?: string;
    /**
     * The worker\'s status within the organization.
     */
    'status'?: GetWorkers200ResponseStatusEnum;
    /**
     * The location that the worker is mapped to for tax purposes. In the case that a worker is remote, the location\'s type is remote.
     */
    'location'?: WorkerLocation;
    /**
     * The worker\'s employment type.
     */
    'employment_type_id'?: string;
    /**
     * The worker\'s employment type.  Expandable field
     */
    'employment_type'?: CompanyEmploymentType;
    /**
     * The gender of the worker, if specified.
     */
    'gender'?: GetWorkers200ResponseGenderEnum;
    /**
     * The worker\'s date of birth.
     */
    'date_of_birth'?: string;
    /**
     * The identified race of the worker, if specified.
     */
    'race'?: GetWorkers200ResponseRaceEnum;
    /**
     * The identified ethnicity of the worker, if specified.
     */
    'ethnicity'?: GetWorkers200ResponseEthnicityEnum;
    /**
     * The countries that the worker has citizenship in.
     */
    'citizenship'?: GetWorkers200ResponseCitizenshipEnum;
    /**
     * The compensation package for the worker.
     */
    'compensation_id'?: string;
    /**
     * The compensation package for the worker.  Expandable field
     */
    'compensation'?: Compensation;
    /**
     * The worker\'s overtime exemption status.
     */
    'overtime_exemption'?: GetWorkers200ResponseOvertimeExemptionEnum;
    /**
     * The worker\'s assigned department.
     */
    'department_id'?: string;
    /**
     * The worker\'s assigned department.  Expandable field
     */
    'department'?: Department;
    /**
     * The worker\'s assigned teams.
     */
    'teams_id'?: Array<string>;
    /**
     * The worker\'s assigned teams.  Expandable field
     */
    'teams'?: Array<Team>;
    /**
     * The worker\'s title.
     */
    'title'?: string;
    /**
     * Title effective date
     */
    'title_effective_date'?: string;
    /**
     * The level of the worker.
     */
    'level_id'?: string;
    /**
     * The level of the worker.  Expandable field
     */
    'level'?: Level;
    /**
     * The details of the worker\'s termination, if applicable.
     */
    'termination_details'?: TerminationDetails;
    /**
     * Custom fields for the worker  Expandable field
     */
    'custom_fields'?: Array<{ [key: string]: object; }>;
    /**
     * Country level fields for the worker.
     */
    'country_fields'?: CountryFields;
    /**
     * Worker\'s assigned business partners unique identifiers
     */
    'business_partners_id'?: Array<string>;
    /**
     * Worker\'s assigned business partners  Expandable field
     */
    'business_partners'?: Array<BusinessPartner>;
}

export const GetWorkers200ResponseCountryEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Cv: 'CV',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Sz: 'SZ',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Xk: 'XK',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    An: 'AN',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mk: 'MK',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Re: 'RE',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sy: 'SY',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Se: 'SE',
    Ch: 'CH',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type GetWorkers200ResponseCountryEnum = typeof GetWorkers200ResponseCountryEnum[keyof typeof GetWorkers200ResponseCountryEnum];
export const GetWorkers200ResponseStatusEnum = {
    Init: 'INIT',
    Hired: 'HIRED',
    Accepted: 'ACCEPTED',
    Active: 'ACTIVE',
    Terminated: 'TERMINATED'
} as const;

export type GetWorkers200ResponseStatusEnum = typeof GetWorkers200ResponseStatusEnum[keyof typeof GetWorkers200ResponseStatusEnum];
export const GetWorkers200ResponseGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Nonbinary: 'NONBINARY',
    Undetermined: 'UNDETERMINED',
    Diverse: 'DIVERSE',
    DoesNotApply: 'DOES_NOT_APPLY',
    PreferNotToSay: 'PREFER_NOT_TO_SAY'
} as const;

export type GetWorkers200ResponseGenderEnum = typeof GetWorkers200ResponseGenderEnum[keyof typeof GetWorkers200ResponseGenderEnum];
export const GetWorkers200ResponseRaceEnum = {
    Black: 'BLACK',
    Brown: 'BROWN',
    Chinese: 'CHINESE',
    Eurasian: 'EURASIAN',
    Indian: 'INDIAN',
    Indigenous: 'INDIGENOUS',
    White: 'WHITE',
    Yellow: 'YELLOW',
    NotInformed: 'NOT_INFORMED',
    Other: 'OTHER'
} as const;

export type GetWorkers200ResponseRaceEnum = typeof GetWorkers200ResponseRaceEnum[keyof typeof GetWorkers200ResponseRaceEnum];
export const GetWorkers200ResponseEthnicityEnum = {
    HispanicOrLatino: 'HISPANIC_OR_LATINO',
    White: 'WHITE',
    BlackOrAfricanAmerican: 'BLACK_OR_AFRICAN_AMERICAN',
    NativeHawaiianOrOtherPacificIslander: 'NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER',
    Asian: 'ASIAN',
    AmericanIndianOrAlaskaNative: 'AMERICAN_INDIAN_OR_ALASKA_NATIVE',
    TwoOrMoreRaces: 'TWO_OR_MORE_RACES',
    DeclineToSelfIdentify: 'DECLINE_TO_SELF_IDENTIFY',
    African: 'AFRICAN',
    Coloured: 'COLOURED',
    Indian: 'INDIAN',
    Other: 'OTHER',
    PreferNotToSay: 'PREFER_NOT_TO_SAY'
} as const;

export type GetWorkers200ResponseEthnicityEnum = typeof GetWorkers200ResponseEthnicityEnum[keyof typeof GetWorkers200ResponseEthnicityEnum];
export const GetWorkers200ResponseCitizenshipEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Cv: 'CV',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Sz: 'SZ',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Xk: 'XK',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    An: 'AN',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mk: 'MK',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Re: 'RE',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sy: 'SY',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Se: 'SE',
    Ch: 'CH',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type GetWorkers200ResponseCitizenshipEnum = typeof GetWorkers200ResponseCitizenshipEnum[keyof typeof GetWorkers200ResponseCitizenshipEnum];
export const GetWorkers200ResponseOvertimeExemptionEnum = {
    Exempt: 'EXEMPT',
    NonExempt: 'NON_EXEMPT'
} as const;

export type GetWorkers200ResponseOvertimeExemptionEnum = typeof GetWorkers200ResponseOvertimeExemptionEnum[keyof typeof GetWorkers200ResponseOvertimeExemptionEnum];

/**
 * 
 */
export interface GroupMember {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The group member\'s full name.
     */
    'full_name'?: string;
    /**
     * The group member\'s associated work email address.
     */
    'work_email'?: string;
}
/**
 * 
 */
export interface HeadcountCompensationData {
    /**
     * Annual base pay for the headcount position
     */
    'base_pay'?: Currency;
    /**
     * Annual bonus for the headcount position
     */
    'bonus'?: Currency;
    /**
     * Annual on target commission for the headcount position
     */
    'commission'?: Currency;
    /**
     * Annual total taxes and benefits compensation for this headcount position
     */
    'tax_and_benefits'?: Currency;
    /**
     * Annual total cash compensation for the headcount position
     */
    'total_cash'?: Currency;
    /**
     * Annual total equity compensation for the headcount position
     */
    'total_equity'?: Currency;
}
/**
 * 
 */
export interface HeadcountPosition {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Position name for the headcount, for ex PID100037
     */
    'position_id'?: string;
    /**
     * Type of headcount position. `OPEN_HEADCOUNT` A headcount position that\'s not yet filled. `FUTURE_START` Headcount where a candidate is going through the hiring process, or an offer has been accepted, but the person has not yet started. `ACTIVE` Headcount where a candidate has been hired and started. `CLOSED` Headcount that\'s no longer available to fill.
     */
    'position_type'?: HeadcountPositionPositionTypeEnum;
    /**
     * More granular classification of headcount position type. `NEW` New headcount created, typically paired with the OPEN_HEADCOUNT type. `BACKFILL` Replacement headcount for someone who left the company. `FORECASTED_ATTRITION` Headcount that does not count toward the budget, also known as provisional position in the application,  `HIRING_STAGE` Person is going through the hiring process, paired with the FUTURE_START type. `OFFER_STAGE` Offer has been extended to a candidate, awaiting their decision. Paired with the FUTURE_START type. `OFFER_ACCEPTED` Candidate has accepted the offer but has not yet started. Paired with the FUTURE_START type. `PLAN_CHANGE` Headcount status changed due to business decision. Paired with CLOSED type. `TERMINATED` Role was filled, but the employee was separated from the company. Paired with CLOSED type. `TRANSFERRED` Employee moved internally to another role. Paired with CLOSED type.
     */
    'position_sub_type'?: HeadcountPositionPositionSubTypeEnum;
    /**
     * ID for the department the headcount belongs to
     */
    'department_id'?: string;
    /**
     * Department the headcount belongs to  Expandable field
     */
    'department'?: Department;
    /**
     * ID for the work location the headcount is assigned to
     */
    'work_location_id'?: string;
    /**
     * Work location the headcount is assigned to  Expandable field
     */
    'work_location'?: WorkLocation;
    /**
     * ID for the level the headcount is assigned to
     */
    'level_id'?: string;
    /**
     * Level the headcount is assigned to  Expandable field
     */
    'level'?: Level;
    /**
     * IDs for the teams the headcount belongs to
     */
    'teams_id'?: Array<string>;
    /**
     * Teams the headcount belongs to  Expandable field
     */
    'teams'?: Array<Team>;
    /**
     * ID for the job requisition the headcount is associated with
     */
    'job_requisition_id'?: string;
    /**
     * Job requisition the headcount is associated with  Expandable field
     */
    'job_requisition'?: JobRequisition;
    /**
     * ID for the recruiter working on filling the position
     */
    'recruiter_id'?: string;
    /**
     * Recruiter working on filling the position  Expandable field
     */
    'recruiter'?: Worker;
    /**
     * ID for the headcount owner
     */
    'headcount_owner_id'?: string;
    /**
     * Owner of the headcount  Expandable field
     */
    'headcount_owner'?: Worker;
    /**
     * Headcount notes
     */
    'notes'?: string;
    /**
     * ID for the worker hired into the headcount
     */
    'worker_id'?: string;
    /**
     * Worker hired into the headcount  Expandable field
     */
    'worker'?: Worker;
    /**
     * ID of the worker for whom this headcount position was requested as a backfill
     */
    'backfill_for_id'?: string;
    /**
     * Worker for whom this headcount position was requested as a backfill  Expandable field
     */
    'backfill_for'?: Worker;
    /**
     * Job title for the position. For a vacant headcount position, this can be defined on creation. Once the position is occupied, its synched from the associated workers job title.
     */
    'title'?: string;
    /**
     * ID for the employment type the headcount is assigned to
     */
    'employment_type_id'?: string;
    /**
     * Employment type the headcount is assigned to  Expandable field
     */
    'employment_type'?: CompanyEmploymentType;
    /**
     * Whether the headcount position is in budget
     */
    'in_budget'?: boolean;
    /**
     * The estimated start date when the position was first created
     */
    'target_start_date'?: string;
    /**
     * Most recent start date estimate or the actual hire date if already filled
     */
    'current_start_date'?: string;
    /**
     * Targeted end date for the headcount
     */
    'end_date'?: string;
    /**
     * ID for the headcount priority
     */
    'priority_id'?: string;
    /**
     * Priority assigned to this headcount  Expandable field
     */
    'priority'?: HeadcountPriority;
    /**
     * ID for the job function the headcount is assigned to
     */
    'job_function_id'?: string;
    /**
     * Job function assigned to this headcount  Expandable field
     */
    'job_function'?: JobFunction;
    /**
     * ID for the location factor the headcount is assigned to
     */
    'location_factor_id'?: string;
    /**
     * Location factor assigned to this headcount  Expandable field
     */
    'location_factor'?: LocationFactor;
    /**
     * Compensation data synched from worker compensation
     */
    'actual_compensation'?: HeadcountCompensationData;
    /**
     * Compensation data defined through comp band
     */
    'comp_band_compensation'?: HeadcountCompensationData;
}

export const HeadcountPositionPositionTypeEnum = {
    OpenHeadcount: 'OPEN_HEADCOUNT',
    FutureStart: 'FUTURE_START',
    Active: 'ACTIVE',
    Closed: 'CLOSED'
} as const;

export type HeadcountPositionPositionTypeEnum = typeof HeadcountPositionPositionTypeEnum[keyof typeof HeadcountPositionPositionTypeEnum];
export const HeadcountPositionPositionSubTypeEnum = {
    New: 'NEW',
    Backfill: 'BACKFILL',
    ForecastedAttrition: 'FORECASTED_ATTRITION',
    HiringStage: 'HIRING_STAGE',
    OfferStage: 'OFFER_STAGE',
    OfferAccepted: 'OFFER_ACCEPTED',
    PlanChange: 'PLAN_CHANGE',
    Terminated: 'TERMINATED',
    Transferred: 'TRANSFERRED'
} as const;

export type HeadcountPositionPositionSubTypeEnum = typeof HeadcountPositionPositionSubTypeEnum[keyof typeof HeadcountPositionPositionSubTypeEnum];

/**
 * 
 */
export interface HeadcountPriority {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Display name of the headcount priority
     */
    'name'?: string;
}
/**
 * 
 */
export interface JobAssignment {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Identifier of worker to whom job is assigned.
     */
    'worker_id': string;
    /**
     * Worker to whom job is assigned.  Expandable field
     */
    'worker'?: Worker;
    /**
     * Base compensation rate of worker
     */
    'base_pay_rate'?: number;
    /**
     * Identifier of job that is assigned to worker
     */
    'job_code_id': string;
    /**
     * Job that is assigned to worker  Expandable field
     */
    'job_code'?: JobCode;
    /**
     * The pay rate for job assigned to worker. This can be different from the job\'s standard pay rate and can be overriden for a worker.
     */
    'job_pay_rate': number;
    /**
     * Identifier of pay rate exceptions applicable for the worker based on certain exception dimension values.
     */
    'job_pay_rate_exceptions_id'?: Array<string>;
    /**
     * Pay rate exceptions applicable for the worker based on certain exception dimension values.  Expandable field
     */
    'job_pay_rate_exceptions'?: Array<JobPayRateException>;
}
/**
 * 
 */
export interface JobCode {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the job dimension.
     */
    'name': string;
    /**
     * The ID of the job dimension this job code belongs to.
     */
    'job_dimension_id': string;
    /**
     * The job dimension this job code belongs to.  Expandable field
     */
    'job_dimension'?: JobDimension;
    /**
     * The unique identifier of the job code in an outside system.
     */
    'external_id'?: string;
    /**
     * The ID of the job roster group.
     */
    'group_id'?: string;
    /**
     * The custom location of the job code. This location will be used for tax calculation purposes if using US Payroll when an employee is working at this job code.
     */
    'custom_location'?: CustomLocation;
    /**
     * The work location associated with the job code.
     */
    'work_location_id'?: string;
    /**
     * The work location associated with the job code.  Expandable field
     */
    'work_location'?: WorkLocation;
    /**
     * The department associated with the job code.
     */
    'department_id'?: string;
    /**
     * The department associated with the job code.  Expandable field
     */
    'department'?: Department;
    /**
     * The pay rate for job, if job code is associated with pay rate.
     */
    'pay_rate'?: number;
    /**
     * Pay rate overrides id for the job based on exception dimension values.
     */
    'pay_rate_exceptions_id'?: Array<string>;
    /**
     * Pay rate overrides for the job based on exception dimension values.  Expandable field
     */
    'pay_rate_exceptions'?: Array<JobPayRateException>;
}
/**
 * 
 */
export interface JobCodeSummary {
    /**
     * List of job code ids that this summary is tracking hours for.
     */
    'job_codes_id'?: Array<string>;
    /**
     * The total hours worked for the job codes.
     */
    'hours_worked'?: number;
}
/**
 * 
 */
export interface JobDimension {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the job dimension
     */
    'name': string;
    /**
     * The unique identifier of the job dimension in a third party system
     */
    'external_id'?: string;
    /**
     * Whether the job dimension includes codes related to a custom location. Only one dimension can have this set to true.
     */
    'includes_custom_location'?: boolean;
    /**
     * The roster type of the dimension. PER_DIMENSION means that there is a group on the dimension level and employees within that group have access to all job codes in the dimension. PER_JOB_CODE means that each job code has its own group.
     */
    'roster_type'?: JobDimensionRosterTypeEnum;
    /**
     * The ID of the dimension roster group.
     */
    'group_id'?: string;
}

export const JobDimensionRosterTypeEnum = {
    PerDimension: 'PER_DIMENSION',
    PerJobCode: 'PER_JOB_CODE'
} as const;

export type JobDimensionRosterTypeEnum = typeof JobDimensionRosterTypeEnum[keyof typeof JobDimensionRosterTypeEnum];

/**
 * 
 */
export interface JobFunction {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Displayed name of the job function
     */
    'name'?: string;
}
/**
 * 
 */
export interface JobPayRateException {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Identifier of Job for which exception is configured.
     */
    'job_code_id': string;
    /**
     * Job for which exception is configured.  Expandable field
     */
    'job_code'?: JobCode;
    /**
     * Type of dimension on which exception is configured
     */
    'exception_dimension_type'?: JobPayRateExceptionExceptionDimensionTypeEnum;
    /**
     * Identifier of dimension object on which exception is configured. This objects details can be queried from exception_dimension_type\'s resource
     */
    'exception_dimension_id': string;
    /**
     * The pay rate for exception on job_code_id and exception_dimension_id combination
     */
    'pay_rate': number;
}

export const JobPayRateExceptionExceptionDimensionTypeEnum = {
    JobCode: 'JOB_CODE',
    Level: 'LEVEL',
    Team: 'TEAM',
    Department: 'DEPARTMENT',
    WorkLocation: 'WORK_LOCATION'
} as const;

export type JobPayRateExceptionExceptionDimensionTypeEnum = typeof JobPayRateExceptionExceptionDimensionTypeEnum[keyof typeof JobPayRateExceptionExceptionDimensionTypeEnum];

/**
 * 
 */
export interface JobRequisition {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Job requisition name
     */
    'name': string;
    /**
     * Job requisition status
     */
    'status': JobRequisitionStatusEnum;
}

export const JobRequisitionStatusEnum = {
    Open: 'OPEN',
    Closed: 'CLOSED',
    Published: 'PUBLISHED',
    Draft: 'DRAFT',
    Archived: 'ARCHIVED'
} as const;

export type JobRequisitionStatusEnum = typeof JobRequisitionStatusEnum[keyof typeof JobRequisitionStatusEnum];

/**
 * 
 */
export interface JobShift {
    /**
     * The start time of the job shift.
     */
    'start_time'?: string;
    /**
     * The end time of the job shift.
     */
    'end_time'?: string;
    /**
     * The original start time of the job shift. If the startTime field has been rounded then this contain the start time before the rounding occured.
     */
    'original_start_time'?: string;
    /**
     * The original end time of the job shift. If the endTime field has been rounded then this contain the end time before the rounding occured.
     */
    'original_end_time'?: string;
    /**
     * The IDs of the job codes associated with the job shift.
     */
    'job_codes_id'?: Array<string>;
    /**
     * Whether the job shift was entered as a duration in hours table
     */
    'is_hours_only_input'?: boolean;
}
/**
 * 
 */
export interface JobShiftRequest {
    /**
     * The start time of the job shift.
     */
    'start_time'?: string;
    /**
     * The end time of the job shift.
     */
    'end_time'?: string;
    /**
     * The duration of the job shift.
     */
    'duration'?: number;
    /**
     * The date of the job shift if using duration.
     */
    'start_date'?: string;
    /**
     * The original start time of the job shift. If the startTime field has been rounded then this contain the start time before the rounding occured.
     */
    'original_start_time'?: string;
    /**
     * The original end time of the job shift. If the endTime field has been rounded then this contain the end time before the rounding occured.
     */
    'original_end_time'?: string;
    /**
     * The IDs of the job codes associated with the job shift.
     */
    'job_codes_id'?: Array<string>;
    /**
     * Whether the job shift was entered as a duration in hours table
     */
    'is_hours_only_input'?: boolean;
}
/**
 *      Leave accrual resource representing time off credits granted to employees.      Leave accruals track the allocation of paid time off (vacation, sick days, etc.)     to employees based on company policies, manual grants, or other accrual sources.     
 */
export interface LeaveAccrual {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID of the worker for whom the accrual is for
     */
    'worker_id': string;
    /**
     * The worker for whom the accrual is for  Expandable field
     */
    'worker'?: Worker;
    /**
     * The ID of the worker who granted this accrual. This is typically the Time Off admin.
     */
    'grantor_id': string;
    /**
     * The worker who granted this accrual. This is typically the Time Off admin.  Expandable field
     */
    'grantor'?: Worker;
    /**
     * The company leave type ID associated with this accrual
     */
    'leave_type_id': string;
    /**
     * The date when this accrual becomes effective
     */
    'accrual_date': string;
    /**
     * The number of hours accrued. It can be negative for deductions. This is applicable if the policy tracks in hours.
     */
    'num_hours'?: number;
    /**
     * The number of days accrued. It can be negative for deductions. This is applicable if the policy tracks in days.
     */
    'num_days'?: number;
    /**
     * The monetary value of this accrual (for policies with monetary tracking)
     */
    'monetary_amount_accrued'?: number;
    /**
     * The date when this accrual expires (if applicable)
     */
    'expiration_date'?: string;
    /**
     * The comment for this accrual. This is required if the leave policy requires a comment on accruals.
     */
    'comment'?: string;
}
/**
 *      Leave accrual resource representing time off credits granted to employees.      Leave accruals track the allocation of paid time off (vacation, sick days, etc.)     to employees based on company policies, manual grants, or other accrual sources.     
 */
export interface LeaveAccrualRequest {
    /**
     * The ID of the worker for whom the accrual is for
     */
    'worker_id': string;
    /**
     * The ID of the worker who granted this accrual. This is typically the Time Off admin.
     */
    'grantor_id': string;
    /**
     * The company leave type ID associated with this accrual
     */
    'leave_type_id': string;
    /**
     * The date when this accrual becomes effective
     */
    'accrual_date': string;
    /**
     * The number of hours accrued. It can be negative for deductions. This is applicable if the policy tracks in hours.
     */
    'num_hours'?: number;
    /**
     * The number of days accrued. It can be negative for deductions. This is applicable if the policy tracks in days.
     */
    'num_days'?: number;
    /**
     * The monetary value of this accrual (for policies with monetary tracking)
     */
    'monetary_amount_accrued'?: number;
    /**
     * The date when this accrual expires (if applicable)
     */
    'expiration_date'?: string;
    /**
     * The comment for this accrual. This is required if the leave policy requires a comment on accruals.
     */
    'comment'?: string;
}
/**
 * 
 */
export interface LeaveBalance {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID of the worker associated with the leave balance.
     */
    'worker_id': string;
    /**
     * The worker associated with the leave balance.  Expandable field
     */
    'worker'?: Worker;
    /**
     * The ID of the leave type associated with the leave balance.
     */
    'leave_type_id'?: string;
    /**
     * The leave type associated with the leave balance.  Expandable field
     */
    'leave_type'?: LeaveType;
    /**
     * Indicates if the leave balance is unlimited.
     */
    'is_balance_unlimited'?: boolean;
    /**
     * The worker\'s leave balance including future leave requests. If the leave balance is unlimited, this field will be null.
     */
    'balance_including_future_requests'?: number;
    /**
     * The worker\'s leave balance excluding future leave requests. If the leave balance is unlimited, this field will be null.
     */
    'balance_excluding_future_requests'?: number;
}
/**
 * 
 */
export interface LeaveRequest {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID of the worker associated with the leave request.
     */
    'worker_id': string;
    /**
     * The worker associated with the leave request.  Expandable field
     */
    'worker'?: Worker;
    /**
     * The ID of the worker who requested the leave request.
     */
    'requester_id'?: string;
    /**
     * The worker who requested the leave request.  Expandable field
     */
    'requester'?: Worker;
    /**
     * The status of the leave request.
     */
    'status': LeaveRequestStatusEnum;
    /**
     * The start date of the leave request.
     */
    'start_date': string;
    /**
     * The start time of the leave request.
     */
    'start_time'?: string;
    /**
     * The end date of the leave request.
     */
    'end_date': string;
    /**
     * The end time of the leave request.
     */
    'end_time'?: string;
    /**
     * The comments associated with the leave request.
     */
    'comments'?: string;
    /**
     * The number of minutes requested for the leave request.
     */
    'number_of_minutes_requested'?: number;
    /**
     * The ID of the leave policy associated with the leave request, either leave_policy_id or leave_type_id must be provided.
     */
    'leave_policy_id'?: string;
    /**
     * The ID of the leave type associated with the leave request, either leave_policy_id or leave_type_id must be provided.
     */
    'leave_type_id'?: string;
    /**
     * The ID of the leave event associated with the leave request, if any.
     */
    'leave_event_id'?: string;
    /**
     * The leave type associated with the leave request.  Expandable field
     */
    'leave_type'?: LeaveType;
    /**
     * The reason for the leave request.
     */
    'reason_for_leave'?: string;
    /**
     * The ID of the worker who reviewed the leave request.
     */
    'reviewer_id'?: string;
    /**
     * The worker who reviewed the leave request.  Expandable field
     */
    'reviewer'?: Worker;
    /**
     * The timestamp of when the leave request was reviewed.
     */
    'reviewed_at'?: string;
    /**
     * The specific dates taken off and the amount of time taken off for each one.
     */
    'days_take_off'?: Array<DayOff>;
    /**
     * Whether the leave request is managed by an external system.
     */
    'is_managed_by_external_system'?: boolean;
}

export const LeaveRequestStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Canceled: 'CANCELED'
} as const;

export type LeaveRequestStatusEnum = typeof LeaveRequestStatusEnum[keyof typeof LeaveRequestStatusEnum];

/**
 * 
 */
export interface LeaveType {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The type of leave.
     */
    'type': string;
    /**
     * The name of the leave type.
     */
    'name': string;
    /**
     * The description of the leave type.
     */
    'description'?: string;
    /**
     * Whether the leave is paid.
     */
    'is_paid': boolean;
    /**
     * Whether the leave is managed by an external system.
     */
    'is_managed_by_external_system': boolean;
}
/**
 * 
 */
export interface LegalEntity {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The tax identifier for the legal entity.
     */
    'tax_identifier'?: string;
    /**
     * The country the legal entity is based in.
     */
    'country'?: Country;
    /**
     * The legal name of the legal entity.
     */
    'legal_name'?: string;
    /**
     * The legal entity\'s level in a hierarchy. * `PARENT`: The legal entity is considered the ultimate holding entity. * `SUBSIDIARY`: The legal entity is considered a subsidiary, fully or partially held by another. * `BRANCH`: The legal entity is considered a branch, associated with a parent legal entity.
     */
    'entity_level'?: LegalEntityEntityLevelEnum;
    /**
     * The registration date of the entity.
     */
    'registration_date'?: string;
    /**
     * The mailing address of the legal entity.
     */
    'mailing_address'?: Address;
    /**
     * The physical address of the legal entity, if it differs from the mailing address.
     */
    'physical_address'?: Address;
    /**
     * The parent legal entity.
     */
    'parent_id'?: string;
    /**
     * The parent legal entity.  Expandable field
     */
    'parent'?: LegalEntity;
    /**
     * The legal entity management type in the case of an employer of record (EOR) or professional employment organization (PEO). * `PEO`: The legal entity is considered a Professional Employment Organization (PEO). * `EOR`: The legal entity is considered an Employer of Record (EOR).
     */
    'management_type'?: LegalEntityManagementTypeEnum;
    /**
     * The company or organization associated with the legal entity
     */
    'company_id'?: string;
    /**
     * The company or organization associated with the legal entity  Expandable field
     */
    'company'?: Company;
}

export const LegalEntityEntityLevelEnum = {
    Parent: 'PARENT',
    Subsidiary: 'SUBSIDIARY',
    Branch: 'BRANCH'
} as const;

export type LegalEntityEntityLevelEnum = typeof LegalEntityEntityLevelEnum[keyof typeof LegalEntityEntityLevelEnum];
export const LegalEntityManagementTypeEnum = {
    Peo: 'PEO',
    Eor: 'EOR'
} as const;

export type LegalEntityManagementTypeEnum = typeof LegalEntityManagementTypeEnum[keyof typeof LegalEntityManagementTypeEnum];

/**
 * 
 */
export interface Level {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the level. Must be unique within the company or organization.
     */
    'name': string;
    /**
     * The parent level.
     */
    'parent_id'?: string;
    /**
     * The parent level.  Expandable field
     */
    'parent'?: Level;
    /**
     * Global level is used to track the seniority of levels. The higher up a level is placed on the page, the more senior and higher-ranked the level. Global level is used in workflows, policies, and reports that use the level attribute (e.g., you can use Level Lookup to set up a workflow that notifies the nearest person in an worker\'s management chain at or above the specified level).
     */
    'global_level'?: number;
    /**
     * The description of the level.
     */
    'description'?: string;
    /**
     * The rank of the level within its track.
     */
    'rank'?: number;
    /**
     * The track associated with the level, if it\'s not a global level.
     */
    'track_id'?: string;
    /**
     * The track associated with the level, if it\'s not a global level.  Expandable field
     */
    'track'?: Track;
}
export interface ListBusinessPartnerGroups200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<BusinessPartnerGroup>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListBusinessPartners200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<BusinessPartner>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListByQueryCustomObjectsCustomObjectApiNameRecords200Response {
    'results'?: Array<CustomObjectDataRow>;
    'cursor'?: string;
}
export interface ListByQueryCustomObjectsCustomObjectApiNameRecordsRequest {
    'query'?: string;
    'limit'?: number;
    'cursor'?: string;
}
export interface ListCompanies200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<Company>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListCustomFields200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<CustomField>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListCustomObjects200Response {
    'results'?: Array<CustomObject>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListCustomObjectsCustomObjectApiNameFields200Response {
    'results'?: Array<CustomObjectField>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListCustomObjectsCustomObjectApiNameRecords200Response {
    'results'?: Array<CustomObjectDataRow>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListDepartments200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<Department>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListEmploymentTypes200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<CompanyEmploymentType>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListEntitlements200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<EntitlementModel>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListJobFunctions200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<JobFunction>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListObjectCategories200Response {
    'results'?: Array<ObjectCategory>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListSupergroups200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<Supergroup>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListSupergroupsGroupIdMembers200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<GroupMember>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListTeams200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<Team>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListUsers200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<User>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListWorkLocations200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<WorkLocation>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
export interface ListWorkers200Response {
    '__meta'?: RedactedFields;
    'results'?: Array<Worker>;
    /**
     * A link to the next page of responses.
     */
    'next_link'?: string;
}
/**
 * Locale settings containing timezone, language, and region preferences.
 */
export interface LocaleSettings {
    /**
     * The user\'s timezone
     */
    'timezone'?: string;
    /**
     * The locale code for formatting
     */
    'locale_code'?: string;
    /**
     * The primary language code
     */
    'language_code'?: string;
    /**
     * Additional language inspection data
     */
    'language_inspection'?: Array<string>;
    /**
     * The region code
     */
    'region_code'?: string;
}
/**
 * 
 */
export interface LocationFactor {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The labor market category (e.g., \"Engineering\", \"Marketing\", \"Sales\")
     */
    'labour_bucket'?: string;
    /**
     * Human-readable name for the location factor
     */
    'display_name'?: string;
    /**
     * Compensation adjustment percentage
     */
    'adjustment_factor'?: number;
    /**
     * Country information set to the country code
     */
    'country'?: Country;
}
/**
 * Meta information for the response.
 */
export interface MetaResponse {
    '__meta'?: MetaResponseMeta;
}
export interface MetaResponseMeta {
    'redacted_fields'?: Array<RedactedField>;
}
/**
 * Personal name information including title, first name, middle name, last name, suffix, and nickname.
 */
export interface Name {
    /**
     * Title or honorific (e.g., Mr., Ms., Dr.)
     */
    'title'?: string;
    /**
     * First name or given name
     */
    'first'?: string;
    /**
     * Middle name(s)
     */
    'middle'?: string;
    /**
     * Last name or family name
     */
    'last'?: string;
    /**
     * Name suffix (e.g., Jr., Sr., III)
     */
    'suffix'?: string;
    /**
     * Preferred nickname or informal name
     */
    'nickname'?: string;
}
/**
 * 
 */
export interface ObjectCategory {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the Custom Category
     */
    'name': string;
    /**
     * The description of the Custom Category
     */
    'description'?: string;
}
/**
 * 
 */
export interface PayPeriod {
    /**
     * The start date of the pay period.
     */
    'start_date'?: string;
    /**
     * The end date of the pay period.
     */
    'end_date'?: string;
    /**
     * The ID of the pay schedule associated with the pay period.
     */
    'pay_schedule_id'?: string;
}
/**
 * 
 */
export interface PayPeriodRequest {
    /**
     * The start date of the pay period.
     */
    'start_date'?: string;
    /**
     * The end date of the pay period.
     */
    'end_date'?: string;
    /**
     * The ID of the pay schedule associated with the pay period.
     */
    'pay_schedule_id'?: string;
}
/**
 * Personal information for a draft hire.
 */
export interface PersonalInfo {
    /**
     * Gender of the candidate
     */
    'gender'?: string;
    /**
     * Date of birth
     */
    'date_of_birth'?: string;
    /**
     * Race of the candidate
     */
    'race'?: string;
    /**
     * Ethnicity of the candidate
     */
    'ethnicity'?: string;
    /**
     * Citizenship of the candidate
     */
    'citizenship'?: string;
    'name': Name;
    /**
     * Social security number of the candidate
     */
    'ssn'?: string;
    'home_address'?: Address;
    'locale'?: LocaleSettings;
    /**
     * Emergency contact name
     */
    'emergency_contact_name'?: string;
    'emergency_contact_phone'?: PhoneNumber;
    /**
     * Invite email of the candidate
     */
    'invite_email': string;
}
/**
 * A phone number with country code, national number, and optional extension.
 */
export interface PhoneNumber {
    /**
     * Country code for the phone number
     */
    'country_code'?: string;
    /**
     * National phone number without country code
     */
    'national_number'?: string;
    /**
     * Phone number extension
     */
    'extension'?: string;
}
/**
 * 
 */
export interface PieceRatePremiums {
    /**
     * The piece rate name.
     */
    'name'?: string;
    /**
     * The pay rate for this piece rate premium.
     */
    'premium_rate'?: number;
    /**
     * The total units produced at the premium rate.
     */
    'premium_units'?: number;
}
/**
 * 
 */
export interface Premiums {
    /**
     * The pay rate name
     */
    'name'?: string;
    /**
     * The pay rate for this premium.
     */
    'premium_rate'?: number;
    /**
     * The total hours worked for at the premium rate.
     */
    'premium_hours'?: number;
}
/**
 * 
 */
export interface PrototypeJob {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The worker\'s ID.
     */
    'prototype_id'?: string;
    /**
     * Job title
     */
    'title'?: string;
    /**
     * Work Location Id
     */
    'work_location_id'?: string;
    /**
     * Work location for the job  Expandable field
     */
    'work_location'?: PrototypeWorkLocation;
}
/**
 * 
 */
export interface PrototypeWorkLocation {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Address for the work location
     */
    'address'?: string;
    /**
     * Whether the work location is remote
     */
    'is_remote'?: boolean;
}
/**
 * Info about the redacted fields.
 */
export interface RedactedField {
    /**
     * The name for the redacted field
     */
    'name'?: string;
    /**
     * The reason for the redaction
     */
    'reason'?: string;
}
/**
 * A list of redacted fields.
 */
export interface RedactedFields {
    'redacted_fields'?: Array<RedactedFieldsRedactedFieldsInner>;
}
export interface RedactedFieldsRedactedFieldsInner {
    /**
     * The name for the redacted field
     */
    'name'?: string;
    /**
     * The reason for the redaction
     */
    'reason'?: string;
}
/**
 * 
 */
export interface SSOMe {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The user\'s work email address.
     */
    'work_email'?: string;
    /**
     * The company ID of the user.
     */
    'company_id'?: string;
    /**
     * The company of the user.  Expandable field
     */
    'company'?: Company;
}
/**
 * 
 */
export interface Schedule {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the schedule.
     */
    'name'?: string;
    /**
     * The IDs of the managers of the schedule.
     */
    'managers_id'?: Array<string>;
    /**
     * The IDs of the observers of the schedule.
     */
    'observers_id'?: Array<string>;
    /**
     * The IDs of the members of the schedule.
     */
    'members_id'?: Array<string>;
    /**
     * The managers of the schedule.  Expandable field
     */
    'managers'?: Array<Worker>;
    /**
     * The observers of the schedule.  Expandable field
     */
    'observers'?: Array<Worker>;
    /**
     * The members of the schedule.  Expandable field
     */
    'members'?: Array<Worker>;
    /**
     * Whether the requesting role can edit the schedule.
     */
    'can_edit'?: boolean;
}
/**
 * 
 */
export interface Segments {
    /**
     * The start time of the segment.
     */
    'start_time'?: string;
    /**
     * The end time of the segment.
     */
    'end_time'?: string;
    /**
     * The IDs of the job codes associated with the segment.
     */
    'job_codes_id'?: Array<string>;
    /**
     * The multiplier for overtime hours in this segment.
     */
    'ot_multiplier'?: number;
    /**
     * Name of the final earning for the segment.
     */
    'display_name'?: string;
    /**
     * The ID of the break type.
     */
    'break_type_id'?: string;
    /**
     * The pay rate for this segment.
     */
    'pay_rate'?: number;
}
/**
 * 
 */
export interface ShiftAssignment {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID of the worker
     */
    'worker_id'?: string;
    /**
     * The worker  Expandable field
     */
    'worker'?: Worker;
    /**
     * The ID of the schedule
     */
    'schedule_id'?: string;
    /**
     * The schedule  Expandable field
     */
    'schedule'?: Schedule;
    /**
     * The data of the shift
     */
    'shift_data'?: ShiftData;
    /**
     * Whether the shift assignment can be edited
     */
    'can_edit': boolean;
    /**
     * Whether the shift assignment is published. If true, the published_version will be the same as the shift_data
     */
    'is_published': boolean;
    /**
     * The published version of the shift assignment, if it exists. If filled but is_published is false, the shift_data is the latest version.
     */
    'published_version'?: ShiftData;
}
/**
 * 
 */
export interface ShiftBreak {
    /**
     * The start time of the shift break
     */
    'start_time': string;
    /**
     * The end time of the shift break
     */
    'end_time': string;
    /**
     * The type of the shift break
     */
    'type': string;
}
/**
 * 
 */
export interface ShiftData {
    /**
     * The start time of the shift
     */
    'start_time': string;
    /**
     * The end time of the shift
     */
    'end_time': string;
    /**
     * The segments of the shift
     */
    'shift_segments': Array<ShiftSegment>;
    /**
     * The breaks of the shift
     */
    'shift_breaks': Array<ShiftBreak>;
}
/**
 * 
 */
export interface ShiftInput {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The creator id associated with the shift input.
     */
    'creator_id'?: string;
    /**
     * The creator associated with the shift input.  Expandable field
     */
    'creator'?: Worker;
    /**
     * Name of the shift unit.
     */
    'name': string;
    /**
     * Prompt for the shift unit.
     */
    'prompt': string;
    /**
     * Type of shift unit.
     */
    'type': string;
    /**
     * Two letter string designating country code which the shift input is associated.
     */
    'country_code': string;
    /**
     * The party that manages this shift input
     */
    'managed_by'?: string;
}
/**
 * 
 */
export interface ShiftInputValue {
    /**
     * The id of the relevant shift input
     */
    'shift_input_id': string;
    /**
     * The value of the shift input.
     */
    'value': object;
    /**
     * The id of the role that last added/updated this input.
     */
    'author_id'?: string;
}
/**
 * 
 */
export interface ShiftInputValueRequest {
    /**
     * The id of the relevant shift input
     */
    'shift_input_id': string;
    /**
     * The value of the shift input.
     */
    'value': object;
    /**
     * The id of the role that last added/updated this input.
     */
    'author_id'?: string;
}
/**
 * 
 */
export interface ShiftSegment {
    /**
     * The start time of the shift segment
     */
    'start_time': string;
    /**
     * The end time of the shift segment
     */
    'end_time': string;
    /**
     * The IDs of the job codes associated with the shift segment
     */
    'job_codes_id'?: Array<string>;
}
/**
 * 
 */
export interface Supergroup {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The group\'s display name.
     */
    'display_name'?: string;
    /**
     * The group\'s name.
     */
    'name'?: string;
    /**
     * The id of the group\'s app owner.
     */
    'app_owner_id'?: string;
    /**
     * The group type
     */
    'group_type'?: string;
    /**
     * The sub group type
     */
    'sub_group_type'?: string;
    /**
     * Whether the group is read only.
     */
    'read_only'?: boolean;
    /**
     * The group\'s description.
     */
    'description'?: string;
    /**
     * The group\'s parent.
     */
    'parent'?: string;
    /**
     * The group\'s mutually exclusive key
     */
    'mutually_exclusive_key'?: string;
    /**
     * Whether the group is the cumulatively exhaustive default
     */
    'cumulatively_exhaustive_default'?: boolean;
    /**
     * Whether the group include terminated roles
     */
    'include_terminated'?: boolean;
    /**
     * Whether the group allows non employees
     */
    'allow_non_employees'?: boolean;
    /**
     * Whether the group can override role states
     */
    'can_override_role_states'?: boolean;
    /**
     * The group\'s priority when calculating mutual exclusivity
     */
    'priority'?: number;
    /**
     * Whether the group is invisible
     */
    'is_invisible'?: boolean;
    /**
     * Whether to ignore provisioning group matching when determining group membership
     */
    'ignore_prov_group_matching'?: boolean;
}
/**
 * 
 */
export interface Team {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The parent team
     */
    'parent_id'?: string;
    /**
     * The parent team  Expandable field
     */
    'parent'?: Team;
    /**
     * The name of the team.
     */
    'name': string;
}
/**
 * 
 */
export interface TerminationDetails {
    /**
     * The termination type indicates whether the termination was voluntary or involuntary.
     */
    'type'?: TerminationDetailsTypeEnum;
    /**
     * This is a description that will be custom to each Rippling company.
     */
    'reason'?: string;
}

export const TerminationDetailsTypeEnum = {
    Voluntary: 'VOLUNTARY',
    Involuntary: 'INVOLUNTARY',
    Retirement: 'RETIREMENT',
    Death: 'DEATH',
    Abandonment: 'ABANDONMENT',
    OfferDeclined: 'OFFER_DECLINED',
    Rescind: 'RESCIND',
    Renege: 'RENEGE'
} as const;

export type TerminationDetailsTypeEnum = typeof TerminationDetailsTypeEnum[keyof typeof TerminationDetailsTypeEnum];

/**
 * 
 */
export interface TimeCard {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID of the worker associated with the time card.
     */
    'worker_id': string;
    /**
     * The worker associated with the time card.  Expandable field
     */
    'worker'?: Worker;
    /**
     * The pay period associated with the time card.
     */
    'pay_period'?: PayPeriod;
    /**
     * The summary of the time card.
     */
    'summary'?: TimeCardSummary;
}
/**
 * 
 */
export interface TimeCardSummary {
    /**
     * The earnings for the pay period.
     */
    'earnings'?: number;
    /**
     * The amount of hours worked for each job code for the pay period.
     */
    'hours_worked_by_job_code'?: Array<JobCodeSummary>;
    /**
     * The premiums for the pay period.
     */
    'premiums'?: number;
    /**
     * The approved hours for the pay period.
     */
    'approved_hours'?: number;
    /**
     * The paid hours for the pay period.
     */
    'paid_hours'?: number;
    /**
     * The total hours for the pay period.
     */
    'total_hours'?: number;
    /**
     * The total paid time off hours for the pay period.
     */
    'total_paid_time_off_hours'?: number;
    /**
     * The total holiday hours for the pay period.
     */
    'total_holiday_hours'?: number;
    /**
     * The total unpaid time off hours for the pay period.
     */
    'total_unpaid_time_off_hours'?: number;
    /**
     * The total number of regular hours worked during the pay period.
     */
    'regular_hours'?: number;
    /**
     * The total number of overtime hours worked during the pay period.
     */
    'overtime_hours'?: number;
    /**
     * The total number of doubletime hours worked during the pay period.
     */
    'double_overtime_hours'?: number;
    /**
     * The map of time entry to unpaidBreakHours in seconds
     */
    'unpaid_break_hours_by_entry'?: number;
}
/**
 * 
 */
export interface TimeEntry {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID of the worker associated with the time entry.
     */
    'worker_id': string;
    /**
     * The worker associated with the time entry.  Expandable field
     */
    'worker'?: Worker;
    /**
     * The start time of the time entry.
     */
    'start_time'?: string;
    /**
     * The end time of the time entry.
     */
    'end_time'?: string;
    /**
     * The comments associated with the time entry.
     */
    'comments'?: Array<TimeEntryComment>;
    /**
     * The job shifts worked during the time entry.
     */
    'job_shifts'?: Array<JobShift>;
    /**
     * The breaks taken during the time entry.
     */
    'breaks'?: Array<Break>;
    /**
     * The premiums earned during the time entry.
     */
    'premiums'?: Array<Premiums>;
    /**
     * The piece-rate premiums earned during the time entry.
     */
    'piece_rate_premiums'?: Array<PieceRatePremiums>;
    /**
     * The pay rates for each segment of the time entry.
     */
    'segments'?: Array<Segments>;
    /**
     * A summary of the time entry.
     */
    'time_entry_summary'?: TimeEntrySummary;
    /**
     * The ID of the time card associated with the time entry.
     */
    'time_card_id'?: string;
    /**
     * The time card associated with the time entry.  Expandable field
     */
    'time_card'?: TimeCard;
    /**
     * The tags associated with the time entry.
     */
    'tags'?: Array<string>;
    /**
     * The unique key of the time entry in an outside system. If set, no other time entry with the same key can be created.
     */
    'idempotency_key'?: string;
    /**
     * Whether the time entry should create an extra hours run.
     */
    'create_extra_hours_run'?: boolean;
    /**
     * The status of the time entry.
     */
    'status'?: TimeEntryStatusEnum;
    /**
     * The pay period associated with the time card.
     */
    'pay_period'?: PayPeriod;
    /**
     * Arbitrary shift inputs collected on the time entry
     */
    'shift_input_values'?: Array<ShiftInputValue>;
}

export const TimeEntryStatusEnum = {
    Draft: 'DRAFT',
    Approved: 'APPROVED',
    Paid: 'PAID',
    Finalized: 'FINALIZED'
} as const;

export type TimeEntryStatusEnum = typeof TimeEntryStatusEnum[keyof typeof TimeEntryStatusEnum];

/**
 * 
 */
export interface TimeEntryComment {
    /**
     * The time the comment was created.
     */
    'created_at'?: string;
    /**
     * The ID of the worker who made of the comment.
     */
    'author_id'?: string;
    /**
     * The text of the comment.
     */
    'text'?: string;
}
/**
 * 
 */
export interface TimeEntryCommentRequest {
    /**
     * The text of the comment.
     */
    'text'?: string;
}
/**
 *      DTO used to store the summary of a TimeEntry     
 */
export interface TimeEntrySummary {
    /**
     * The number of overtime hours worked during this time entry.
     */
    'over_time_hours'?: number;
    /**
     * The number of double overtime hours worked during this time entry.
     */
    'double_over_time_hours'?: number;
    /**
     * The number of regular hours worked during this time entry.
     */
    'regular_hours'?: number;
    /**
     * The duration of the time entry.
     */
    'duration'?: number;
}
/**
 * 
 */
export interface TimeKioskBadge {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The ID associated with the badge. Not to be confused with the record\'s ID.
     */
    'badge_id': string;
    /**
     * The worker associated with the badge.  Expandable field
     */
    'worker'?: Worker;
    /**
     * The ID of the worker associated with the badge.
     */
    'worker_id'?: string;
    /**
     * The employee number of the worker associated with the badge.
     */
    'worker_number'?: number;
    /**
     * Whether this badge can be used with the Kiosk app.
     */
    'is_enabled'?: boolean;
}
/**
 * 
 */
export interface Track {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the track. Must be unique within the company or organization.
     */
    'name': string;
}
/**
 * 
 */
export interface USFields {
    /**
     * Social Security Number (SSN) for US employees.
     */
    'ssn'?: string;
}
export interface UpdateCustomObjectsCustomObjectApiNameFieldsRequest {
    'name'?: string;
    'description'?: string;
    'data_type'?: object;
    'required'?: boolean;
    'rql_definition'?: object;
    'is_unique'?: boolean;
    'formula_attr_metas'?: object;
    'section'?: object;
    'enable_history'?: boolean;
    'derived_field_formula'?: string;
    'name_field_details'?: object;
}
export interface UpdateCustomObjectsRequest {
    'name'?: string;
    'description'?: string;
    'category'?: string;
    'plural_label'?: string;
    'owner_role'?: string;
}
export interface UpdateSupergroupsGroupIdInclusionMembers200Response {
    /**
     * Whether the operation succeeded.
     */
    'ok'?: boolean;
}
export interface UpdateSupergroupsGroupIdInclusionMembersRequest {
    'Operations'?: Array<UpdateSupergroupsGroupIdInclusionMembersRequestOperationsInner>;
}
export interface UpdateSupergroupsGroupIdInclusionMembersRequestOperationsInner {
    /**
     * add or remove
     */
    'op'?: string;
    /**
     * The members to add or remove.
     */
    'value'?: Array<UpdateSupergroupsGroupIdInclusionMembersRequestOperationsInnerValueInner>;
}
export interface UpdateSupergroupsGroupIdInclusionMembersRequestOperationsInnerValueInner {
    /**
     * A member id.
     */
    'id'?: string;
}
/**
 * 
 */
export interface User {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * Whether the user is able to access company resources, typically when they are in actively engaged with the company and not after off-boarding.
     */
    'active'?: boolean;
    /**
     * The unique identifier across Rippling used by the User for direct authentication into their associated company. Globally unique.
     */
    'username'?: string;
    /**
     * The user\'s name.
     */
    'name'?: UserName;
    /**
     * The display name of the user using either the concatenated preferred given and family name or username depending on availability.
     */
    'display_name'?: string;
    /**
     * The user\'s email addresses.
     */
    'emails'?: Array<Email>;
    /**
     * The user\'s phone numbers.
     */
    'phone_numbers'?: Array<UserPhoneNumber>;
    /**
     * The user\'s addresses.
     */
    'addresses'?: Array<UserAddress>;
    /**
     * The user\'s photos.
     */
    'photos'?: Array<UserPhoto>;
    /**
     * The User\'s preferred written or spoken language in the same format of the HTTP Accept-Language header, pursuant to Section 5.3.5 of RFC7231.
     */
    'preferred_language'?: string;
    /**
     * The User\'s default location for purposes of localization of currency, date time format, or numerical representations pursuant to RFC5646.
     */
    'locale'?: string;
    /**
     * The User\'s current time zone in IANA database Olson format
     */
    'timezone'?: string;
    /**
     * The permanent profile number of the user.
     */
    'number'?: string;
}
/**
 * 
 */
export interface UserAddress {
    /**
     * The classification of the address.
     */
    'type'?: UserAddressTypeEnum;
    /**
     * The formatted mailing address.
     */
    'formatted'?: string;
    /**
     * The full street address component, which may include house number, street name, P.O. box, and multi-line extended street address information, pursuant to SCIM RFC 7643 4.1.2..
     */
    'street_address'?: string;
    /**
     * The city or locality component.
     */
    'locality'?: string;
    /**
     * The state or region component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'region'?: string;
    /**
     * The zip code or postal code component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'postal_code'?: string;
    /**
     * The country component, pursuant to SCIM RFC 7643 4.1.2.
     */
    'country'?: UserAddressCountryEnum;
}

export const UserAddressTypeEnum = {
    Home: 'HOME',
    Work: 'WORK',
    Other: 'OTHER'
} as const;

export type UserAddressTypeEnum = typeof UserAddressTypeEnum[keyof typeof UserAddressTypeEnum];
export const UserAddressCountryEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Cv: 'CV',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Sz: 'SZ',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Xk: 'XK',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    An: 'AN',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mk: 'MK',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Re: 'RE',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sy: 'SY',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Se: 'SE',
    Ch: 'CH',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type UserAddressCountryEnum = typeof UserAddressCountryEnum[keyof typeof UserAddressCountryEnum];

/**
 * 
 */
export interface UserName {
    /**
     * The user\'s full name.
     */
    'formatted'?: string;
    /**
     * The given legal name of the user, or first name in most Western languages.
     */
    'given_name'?: string;
    /**
     * The middle name(s) of the user.
     */
    'middle_name'?: string;
    /**
     * The legal family name of the user, or last name in most Western languages.
     */
    'family_name'?: string;
    /**
     * The preferred given name, or first name in most Western languages, by the user.
     */
    'preferred_given_name'?: string;
    /**
     * The preferred family name, or last name in most Western languages, by the user.
     */
    'preferred_family_name'?: string;
}
/**
 * 
 */
export interface UserPhoneNumber {
    /**
     * The canonical global phone number pursuant to RFC3966.
     */
    'value'?: string;
    /**
     * The classification of the phone number, pursuant to SCIM RFC 7643 4.1.2.
     */
    'type'?: UserPhoneNumberTypeEnum;
    /**
     * The display value of the phone number.
     */
    'display'?: string;
}

export const UserPhoneNumberTypeEnum = {
    Home: 'HOME',
    Work: 'WORK',
    Mobile: 'MOBILE',
    Fax: 'FAX',
    Other: 'OTHER'
} as const;

export type UserPhoneNumberTypeEnum = typeof UserPhoneNumberTypeEnum[keyof typeof UserPhoneNumberTypeEnum];

/**
 * 
 */
export interface UserPhoto {
    /**
     * The URL of the photo.
     */
    'value'?: string;
    /**
     * The classification of the photo.
     */
    'type'?: UserPhotoTypeEnum;
}

export const UserPhotoTypeEnum = {
    Photo: 'PHOTO',
    Thumbnail: 'THUMBNAIL'
} as const;

export type UserPhotoTypeEnum = typeof UserPhotoTypeEnum[keyof typeof UserPhotoTypeEnum];

/**
 * 
 */
export interface WorkLocation {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The name of the work location.
     */
    'name': string;
    /**
     * The address for the work location.
     */
    'address': Address;
}
/**
 * Work location information for a draft hire.
 */
export interface WorkLocationInfo {
    /**
     * Work location ID
     */
    'location_id'?: string;
    /**
     * Whether the work location is remote
     */
    'is_remote'?: boolean;
    /**
     * Country code of the work location
     */
    'country_code'?: string;
}
/**
 * 
 */
export interface Worker {
    /**
     * Identifier field
     */
    'id': string;
    /**
     * Record creation date
     */
    'created_at': string;
    /**
     * Record update date
     */
    'updated_at': string;
    /**
     * The worker\'s associated user.
     */
    'user_id'?: string;
    /**
     * The worker\'s associated user.  Expandable field
     */
    'user'?: User;
    /**
     * Whether the worker is a manager
     */
    'is_manager'?: boolean;
    /**
     * The worker\'s manager.
     */
    'manager_id'?: string;
    /**
     * The worker\'s manager.  Expandable field
     */
    'manager'?: Worker;
    /**
     * The worker\'s associated legal entity.
     */
    'legal_entity_id'?: string;
    /**
     * The worker\'s associated legal entity.  Expandable field
     */
    'legal_entity'?: LegalEntity;
    /**
     * The worker\'s country.
     */
    'country'?: WorkerCountryEnum;
    /**
     * The start date of the worker.
     */
    'start_date'?: string;
    /**
     * The end date of the worker.
     */
    'end_date'?: string;
    /**
     * The worker\'s number within the organization.
     */
    'number'?: number;
    /**
     * The worker\'s associated work email address.
     */
    'work_email'?: string;
    /**
     * The worker\'s associated personal email address.
     */
    'personal_email'?: string;
    /**
     * The worker\'s status within the organization.
     */
    'status'?: WorkerStatusEnum;
    /**
     * The location that the worker is mapped to for tax purposes. In the case that a worker is remote, the location\'s type is remote.
     */
    'location'?: WorkerLocation;
    /**
     * The worker\'s employment type.
     */
    'employment_type_id'?: string;
    /**
     * The worker\'s employment type.  Expandable field
     */
    'employment_type'?: CompanyEmploymentType;
    /**
     * The gender of the worker, if specified.
     */
    'gender'?: WorkerGenderEnum;
    /**
     * The worker\'s date of birth.
     */
    'date_of_birth'?: string;
    /**
     * The identified race of the worker, if specified.
     */
    'race'?: WorkerRaceEnum;
    /**
     * The identified ethnicity of the worker, if specified.
     */
    'ethnicity'?: WorkerEthnicityEnum;
    /**
     * The countries that the worker has citizenship in.
     */
    'citizenship'?: WorkerCitizenshipEnum;
    /**
     * The compensation package for the worker.
     */
    'compensation_id'?: string;
    /**
     * The compensation package for the worker.  Expandable field
     */
    'compensation'?: Compensation;
    /**
     * The worker\'s overtime exemption status.
     */
    'overtime_exemption'?: WorkerOvertimeExemptionEnum;
    /**
     * The worker\'s assigned department.
     */
    'department_id'?: string;
    /**
     * The worker\'s assigned department.  Expandable field
     */
    'department'?: Department;
    /**
     * The worker\'s assigned teams.
     */
    'teams_id'?: Array<string>;
    /**
     * The worker\'s assigned teams.  Expandable field
     */
    'teams'?: Array<Team>;
    /**
     * The worker\'s title.
     */
    'title'?: string;
    /**
     * Title effective date
     */
    'title_effective_date'?: string;
    /**
     * The level of the worker.
     */
    'level_id'?: string;
    /**
     * The level of the worker.  Expandable field
     */
    'level'?: Level;
    /**
     * The details of the worker\'s termination, if applicable.
     */
    'termination_details'?: TerminationDetails;
    /**
     * Custom fields for the worker  Expandable field
     */
    'custom_fields'?: Array<{ [key: string]: any; }>;
    /**
     * Country level fields for the worker.
     */
    'country_fields'?: CountryFields;
    /**
     * Worker\'s assigned business partners unique identifiers
     */
    'business_partners_id'?: Array<string>;
    /**
     * Worker\'s assigned business partners  Expandable field
     */
    'business_partners'?: Array<BusinessPartner>;
}

export const WorkerCountryEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Cv: 'CV',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Sz: 'SZ',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Xk: 'XK',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    An: 'AN',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mk: 'MK',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Re: 'RE',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sy: 'SY',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Se: 'SE',
    Ch: 'CH',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type WorkerCountryEnum = typeof WorkerCountryEnum[keyof typeof WorkerCountryEnum];
export const WorkerStatusEnum = {
    Init: 'INIT',
    Hired: 'HIRED',
    Accepted: 'ACCEPTED',
    Active: 'ACTIVE',
    Terminated: 'TERMINATED'
} as const;

export type WorkerStatusEnum = typeof WorkerStatusEnum[keyof typeof WorkerStatusEnum];
export const WorkerGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Nonbinary: 'NONBINARY',
    Undetermined: 'UNDETERMINED',
    Diverse: 'DIVERSE',
    DoesNotApply: 'DOES_NOT_APPLY',
    PreferNotToSay: 'PREFER_NOT_TO_SAY'
} as const;

export type WorkerGenderEnum = typeof WorkerGenderEnum[keyof typeof WorkerGenderEnum];
export const WorkerRaceEnum = {
    Black: 'BLACK',
    Brown: 'BROWN',
    Chinese: 'CHINESE',
    Eurasian: 'EURASIAN',
    Indian: 'INDIAN',
    Indigenous: 'INDIGENOUS',
    White: 'WHITE',
    Yellow: 'YELLOW',
    NotInformed: 'NOT_INFORMED',
    Other: 'OTHER'
} as const;

export type WorkerRaceEnum = typeof WorkerRaceEnum[keyof typeof WorkerRaceEnum];
export const WorkerEthnicityEnum = {
    HispanicOrLatino: 'HISPANIC_OR_LATINO',
    White: 'WHITE',
    BlackOrAfricanAmerican: 'BLACK_OR_AFRICAN_AMERICAN',
    NativeHawaiianOrOtherPacificIslander: 'NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER',
    Asian: 'ASIAN',
    AmericanIndianOrAlaskaNative: 'AMERICAN_INDIAN_OR_ALASKA_NATIVE',
    TwoOrMoreRaces: 'TWO_OR_MORE_RACES',
    DeclineToSelfIdentify: 'DECLINE_TO_SELF_IDENTIFY',
    African: 'AFRICAN',
    Coloured: 'COLOURED',
    Indian: 'INDIAN',
    Other: 'OTHER',
    PreferNotToSay: 'PREFER_NOT_TO_SAY'
} as const;

export type WorkerEthnicityEnum = typeof WorkerEthnicityEnum[keyof typeof WorkerEthnicityEnum];
export const WorkerCitizenshipEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Cv: 'CV',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Sz: 'SZ',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kr: 'KR',
    Xk: 'XK',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    An: 'AN',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mk: 'MK',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Re: 'RE',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sy: 'SY',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Se: 'SE',
    Ch: 'CH',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type WorkerCitizenshipEnum = typeof WorkerCitizenshipEnum[keyof typeof WorkerCitizenshipEnum];
export const WorkerOvertimeExemptionEnum = {
    Exempt: 'EXEMPT',
    NonExempt: 'NON_EXEMPT'
} as const;

export type WorkerOvertimeExemptionEnum = typeof WorkerOvertimeExemptionEnum[keyof typeof WorkerOvertimeExemptionEnum];

/**
 * 
 */
export interface WorkerLocation {
    /**
     * The type of location.
     */
    'type': WorkerLocationTypeEnum;
    /**
     * The work location, if the worker isn\'t remote.
     */
    'work_location_id': string;
}

export const WorkerLocationTypeEnum = {
    Remote: 'REMOTE',
    Work: 'WORK'
} as const;

export type WorkerLocationTypeEnum = typeof WorkerLocationTypeEnum[keyof typeof WorkerLocationTypeEnum];


/**
 * BusinessPartnersApi - axios parameter creator
 */
export const BusinessPartnersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new business partner group
         * @summary Create a new business partner group
         * @param {BusinessPartnerGroupRequest} [businessPartnerGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPartnerGroups: async (businessPartnerGroupRequest?: BusinessPartnerGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-partner-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["business-partner-groups.read", "business-partner-groups.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessPartnerGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new business partner
         * @summary Create a new business partner
         * @param {BusinessPartnerRequest} [businessPartnerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPartners: async (businessPartnerRequest?: BusinessPartnerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-partners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["business-partners.read", "business-partners.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessPartnerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a business partner group
         * @param {string} id ID of the resource to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessPartnerGroups: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBusinessPartnerGroups', 'id', id)
            const localVarPath = `/business-partner-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["business-partner-groups.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a business partner
         * @param {string} id ID of the resource to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessPartners: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBusinessPartners', 'id', id)
            const localVarPath = `/business-partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["business-partners.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific business partner group
         * @summary Retrieve a specific business partner group
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPartnerGroups: async (id: string, expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessPartnerGroups', 'id', id)
            const localVarPath = `/business-partner-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["business-partner-groups.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific business partner
         * @summary Retrieve a specific business partner
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPartners: async (id: string, expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessPartners', 'id', id)
            const localVarPath = `/business-partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["business-partners.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of business partner groups  - Requires: `API Tier 1`  - Expandable fields: `default_business_partner`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List business partner groups
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessPartnerGroups: async (expand?: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-partner-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["business-partner-groups.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of business partners  - Requires: `API Tier 1`  - Filterable fields: `worker_id`, `business_partner_group_id`  - Expandable fields: `business_partner_group`, `worker`, `client_group`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List business partners
         * @param {string} [filter] 
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessPartners: async (filter?: string, expand?: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-partners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["business-partners.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessPartnersApi - functional programming interface
 */
export const BusinessPartnersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessPartnersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new business partner group
         * @summary Create a new business partner group
         * @param {BusinessPartnerGroupRequest} [businessPartnerGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessPartnerGroups(businessPartnerGroupRequest?: BusinessPartnerGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessPartnerGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessPartnerGroups(businessPartnerGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessPartnersApi.createBusinessPartnerGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new business partner
         * @summary Create a new business partner
         * @param {BusinessPartnerRequest} [businessPartnerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessPartners(businessPartnerRequest?: BusinessPartnerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessPartner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessPartners(businessPartnerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessPartnersApi.createBusinessPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a business partner group
         * @param {string} id ID of the resource to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBusinessPartnerGroups(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBusinessPartnerGroups(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessPartnersApi.deleteBusinessPartnerGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a business partner
         * @param {string} id ID of the resource to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBusinessPartners(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBusinessPartners(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessPartnersApi.deleteBusinessPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific business partner group
         * @summary Retrieve a specific business partner group
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessPartnerGroups(id: string, expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessPartnerGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessPartnerGroups(id, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessPartnersApi.getBusinessPartnerGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific business partner
         * @summary Retrieve a specific business partner
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessPartners(id: string, expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessPartners200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessPartners(id, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessPartnersApi.getBusinessPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of business partner groups  - Requires: `API Tier 1`  - Expandable fields: `default_business_partner`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List business partner groups
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBusinessPartnerGroups(expand?: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBusinessPartnerGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBusinessPartnerGroups(expand, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessPartnersApi.listBusinessPartnerGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of business partners  - Requires: `API Tier 1`  - Filterable fields: `worker_id`, `business_partner_group_id`  - Expandable fields: `business_partner_group`, `worker`, `client_group`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List business partners
         * @param {string} [filter] 
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBusinessPartners(filter?: string, expand?: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBusinessPartners200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBusinessPartners(filter, expand, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessPartnersApi.listBusinessPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BusinessPartnersApi - factory interface
 */
export const BusinessPartnersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessPartnersApiFp(configuration)
    return {
        /**
         * Create a new business partner group
         * @summary Create a new business partner group
         * @param {BusinessPartnersApiCreateBusinessPartnerGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPartnerGroups(requestParameters: BusinessPartnersApiCreateBusinessPartnerGroupsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BusinessPartnerGroup> {
            return localVarFp.createBusinessPartnerGroups(requestParameters.businessPartnerGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new business partner
         * @summary Create a new business partner
         * @param {BusinessPartnersApiCreateBusinessPartnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessPartners(requestParameters: BusinessPartnersApiCreateBusinessPartnersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BusinessPartner> {
            return localVarFp.createBusinessPartners(requestParameters.businessPartnerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a business partner group
         * @param {BusinessPartnersApiDeleteBusinessPartnerGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessPartnerGroups(requestParameters: BusinessPartnersApiDeleteBusinessPartnerGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBusinessPartnerGroups(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a business partner
         * @param {BusinessPartnersApiDeleteBusinessPartnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessPartners(requestParameters: BusinessPartnersApiDeleteBusinessPartnersRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBusinessPartners(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific business partner group
         * @summary Retrieve a specific business partner group
         * @param {BusinessPartnersApiGetBusinessPartnerGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPartnerGroups(requestParameters: BusinessPartnersApiGetBusinessPartnerGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetBusinessPartnerGroups200Response> {
            return localVarFp.getBusinessPartnerGroups(requestParameters.id, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific business partner
         * @summary Retrieve a specific business partner
         * @param {BusinessPartnersApiGetBusinessPartnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPartners(requestParameters: BusinessPartnersApiGetBusinessPartnersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetBusinessPartners200Response> {
            return localVarFp.getBusinessPartners(requestParameters.id, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of business partner groups  - Requires: `API Tier 1`  - Expandable fields: `default_business_partner`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List business partner groups
         * @param {BusinessPartnersApiListBusinessPartnerGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessPartnerGroups(requestParameters: BusinessPartnersApiListBusinessPartnerGroupsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListBusinessPartnerGroups200Response> {
            return localVarFp.listBusinessPartnerGroups(requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of business partners  - Requires: `API Tier 1`  - Filterable fields: `worker_id`, `business_partner_group_id`  - Expandable fields: `business_partner_group`, `worker`, `client_group`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List business partners
         * @param {BusinessPartnersApiListBusinessPartnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessPartners(requestParameters: BusinessPartnersApiListBusinessPartnersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListBusinessPartners200Response> {
            return localVarFp.listBusinessPartners(requestParameters.filter, requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBusinessPartnerGroups operation in BusinessPartnersApi.
 */
export interface BusinessPartnersApiCreateBusinessPartnerGroupsRequest {
    readonly businessPartnerGroupRequest?: BusinessPartnerGroupRequest
}

/**
 * Request parameters for createBusinessPartners operation in BusinessPartnersApi.
 */
export interface BusinessPartnersApiCreateBusinessPartnersRequest {
    readonly businessPartnerRequest?: BusinessPartnerRequest
}

/**
 * Request parameters for deleteBusinessPartnerGroups operation in BusinessPartnersApi.
 */
export interface BusinessPartnersApiDeleteBusinessPartnerGroupsRequest {
    /**
     * ID of the resource to delete
     */
    readonly id: string
}

/**
 * Request parameters for deleteBusinessPartners operation in BusinessPartnersApi.
 */
export interface BusinessPartnersApiDeleteBusinessPartnersRequest {
    /**
     * ID of the resource to delete
     */
    readonly id: string
}

/**
 * Request parameters for getBusinessPartnerGroups operation in BusinessPartnersApi.
 */
export interface BusinessPartnersApiGetBusinessPartnerGroupsRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string

    readonly expand?: string
}

/**
 * Request parameters for getBusinessPartners operation in BusinessPartnersApi.
 */
export interface BusinessPartnersApiGetBusinessPartnersRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string

    readonly expand?: string
}

/**
 * Request parameters for listBusinessPartnerGroups operation in BusinessPartnersApi.
 */
export interface BusinessPartnersApiListBusinessPartnerGroupsRequest {
    readonly expand?: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for listBusinessPartners operation in BusinessPartnersApi.
 */
export interface BusinessPartnersApiListBusinessPartnersRequest {
    readonly filter?: string

    readonly expand?: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * BusinessPartnersApi - object-oriented interface
 */
export class BusinessPartnersApi extends BaseAPI {
    /**
     * Create a new business partner group
     * @summary Create a new business partner group
     * @param {BusinessPartnersApiCreateBusinessPartnerGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBusinessPartnerGroups(requestParameters: BusinessPartnersApiCreateBusinessPartnerGroupsRequest = {}, options?: RawAxiosRequestConfig) {
        return BusinessPartnersApiFp(this.configuration).createBusinessPartnerGroups(requestParameters.businessPartnerGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new business partner
     * @summary Create a new business partner
     * @param {BusinessPartnersApiCreateBusinessPartnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBusinessPartners(requestParameters: BusinessPartnersApiCreateBusinessPartnersRequest = {}, options?: RawAxiosRequestConfig) {
        return BusinessPartnersApiFp(this.configuration).createBusinessPartners(requestParameters.businessPartnerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a business partner group
     * @param {BusinessPartnersApiDeleteBusinessPartnerGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteBusinessPartnerGroups(requestParameters: BusinessPartnersApiDeleteBusinessPartnerGroupsRequest, options?: RawAxiosRequestConfig) {
        return BusinessPartnersApiFp(this.configuration).deleteBusinessPartnerGroups(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a business partner
     * @param {BusinessPartnersApiDeleteBusinessPartnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteBusinessPartners(requestParameters: BusinessPartnersApiDeleteBusinessPartnersRequest, options?: RawAxiosRequestConfig) {
        return BusinessPartnersApiFp(this.configuration).deleteBusinessPartners(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific business partner group
     * @summary Retrieve a specific business partner group
     * @param {BusinessPartnersApiGetBusinessPartnerGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinessPartnerGroups(requestParameters: BusinessPartnersApiGetBusinessPartnerGroupsRequest, options?: RawAxiosRequestConfig) {
        return BusinessPartnersApiFp(this.configuration).getBusinessPartnerGroups(requestParameters.id, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific business partner
     * @summary Retrieve a specific business partner
     * @param {BusinessPartnersApiGetBusinessPartnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinessPartners(requestParameters: BusinessPartnersApiGetBusinessPartnersRequest, options?: RawAxiosRequestConfig) {
        return BusinessPartnersApiFp(this.configuration).getBusinessPartners(requestParameters.id, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of business partner groups  - Requires: `API Tier 1`  - Expandable fields: `default_business_partner`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List business partner groups
     * @param {BusinessPartnersApiListBusinessPartnerGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listBusinessPartnerGroups(requestParameters: BusinessPartnersApiListBusinessPartnerGroupsRequest = {}, options?: RawAxiosRequestConfig) {
        return BusinessPartnersApiFp(this.configuration).listBusinessPartnerGroups(requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of business partners  - Requires: `API Tier 1`  - Filterable fields: `worker_id`, `business_partner_group_id`  - Expandable fields: `business_partner_group`, `worker`, `client_group`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List business partners
     * @param {BusinessPartnersApiListBusinessPartnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listBusinessPartners(requestParameters: BusinessPartnersApiListBusinessPartnersRequest = {}, options?: RawAxiosRequestConfig) {
        return BusinessPartnersApiFp(this.configuration).listBusinessPartners(requestParameters.filter, requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompaniesApi - axios parameter creator
 */
export const CompaniesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A List of companies  - Requires: `API Tier 1`  - Expandable fields: `parent_legal_entity`, `legal_entities`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List companies
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCompanies: async (expand?: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["companies.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompaniesApi - functional programming interface
 */
export const CompaniesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompaniesApiAxiosParamCreator(configuration)
    return {
        /**
         * A List of companies  - Requires: `API Tier 1`  - Expandable fields: `parent_legal_entity`, `legal_entities`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List companies
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCompanies(expand?: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCompanies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompanies(expand, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.listCompanies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompaniesApi - factory interface
 */
export const CompaniesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompaniesApiFp(configuration)
    return {
        /**
         * A List of companies  - Requires: `API Tier 1`  - Expandable fields: `parent_legal_entity`, `legal_entities`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List companies
         * @param {CompaniesApiListCompaniesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCompanies(requestParameters: CompaniesApiListCompaniesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListCompanies200Response> {
            return localVarFp.listCompanies(requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listCompanies operation in CompaniesApi.
 */
export interface CompaniesApiListCompaniesRequest {
    readonly expand?: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * CompaniesApi - object-oriented interface
 */
export class CompaniesApi extends BaseAPI {
    /**
     * A List of companies  - Requires: `API Tier 1`  - Expandable fields: `parent_legal_entity`, `legal_entities`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List companies
     * @param {CompaniesApiListCompaniesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCompanies(requestParameters: CompaniesApiListCompaniesRequest = {}, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).listCompanies(requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomFieldsApi - axios parameter creator
 */
export const CustomFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A List of custom fields  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List custom fields
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFields: async (orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/custom-fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-fields.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomFieldsApi - functional programming interface
 */
export const CustomFieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * A List of custom fields  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List custom fields
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomFields(orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCustomFields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomFields(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomFieldsApi.listCustomFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomFieldsApi - factory interface
 */
export const CustomFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomFieldsApiFp(configuration)
    return {
        /**
         * A List of custom fields  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List custom fields
         * @param {CustomFieldsApiListCustomFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFields(requestParameters: CustomFieldsApiListCustomFieldsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListCustomFields200Response> {
            return localVarFp.listCustomFields(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listCustomFields operation in CustomFieldsApi.
 */
export interface CustomFieldsApiListCustomFieldsRequest {
    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * CustomFieldsApi - object-oriented interface
 */
export class CustomFieldsApi extends BaseAPI {
    /**
     * A List of custom fields  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List custom fields
     * @param {CustomFieldsApiListCustomFieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCustomFields(requestParameters: CustomFieldsApiListCustomFieldsRequest = {}, options?: RawAxiosRequestConfig) {
        return CustomFieldsApiFp(this.configuration).listCustomFields(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomObjectFieldsApi - axios parameter creator
 */
export const CustomObjectFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new custom object field
         * @summary Create a new custom object field
         * @param {string} customObjectApiName 
         * @param {CreateCustomObjectsCustomObjectApiNameFieldsRequest} [createCustomObjectsCustomObjectApiNameFieldsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomObjectsCustomObjectApiNameFields: async (customObjectApiName: string, createCustomObjectsCustomObjectApiNameFieldsRequest?: CreateCustomObjectsCustomObjectApiNameFieldsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('createCustomObjectsCustomObjectApiNameFields', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/fields/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomObjectsCustomObjectApiNameFieldsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a custom object field
         * @summary Delete a custom object field
         * @param {string} customObjectApiName 
         * @param {string} fieldApiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomObjectsCustomObjectApiNameFields: async (customObjectApiName: string, fieldApiName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('deleteCustomObjectsCustomObjectApiNameFields', 'customObjectApiName', customObjectApiName)
            // verify required parameter 'fieldApiName' is not null or undefined
            assertParamExists('deleteCustomObjectsCustomObjectApiNameFields', 'fieldApiName', fieldApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/fields/{field_api_name}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)))
                .replace(`{${"field_api_name"}}`, encodeURIComponent(String(fieldApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific custom object field
         * @summary Retrieve a specific custom object field
         * @param {string} customObjectApiName 
         * @param {string} fieldApiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomObjectsCustomObjectApiNameFields: async (customObjectApiName: string, fieldApiName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('getCustomObjectsCustomObjectApiNameFields', 'customObjectApiName', customObjectApiName)
            // verify required parameter 'fieldApiName' is not null or undefined
            assertParamExists('getCustomObjectsCustomObjectApiNameFields', 'fieldApiName', fieldApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/fields/{field_api_name}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)))
                .replace(`{${"field_api_name"}}`, encodeURIComponent(String(fieldApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read", "custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of custom object fields  - Requires: `API Tier 1`
         * @summary List custom object fields
         * @param {string} customObjectApiName 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomObjectsCustomObjectApiNameFields: async (customObjectApiName: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('listCustomObjectsCustomObjectApiNameFields', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/fields/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read", "custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updated a specific custom object field
         * @summary Update a custom object field
         * @param {string} customObjectApiName 
         * @param {string} fieldApiName 
         * @param {UpdateCustomObjectsCustomObjectApiNameFieldsRequest} [updateCustomObjectsCustomObjectApiNameFieldsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomObjectsCustomObjectApiNameFields: async (customObjectApiName: string, fieldApiName: string, updateCustomObjectsCustomObjectApiNameFieldsRequest?: UpdateCustomObjectsCustomObjectApiNameFieldsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('updateCustomObjectsCustomObjectApiNameFields', 'customObjectApiName', customObjectApiName)
            // verify required parameter 'fieldApiName' is not null or undefined
            assertParamExists('updateCustomObjectsCustomObjectApiNameFields', 'fieldApiName', fieldApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/fields/{field_api_name}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)))
                .replace(`{${"field_api_name"}}`, encodeURIComponent(String(fieldApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomObjectsCustomObjectApiNameFieldsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomObjectFieldsApi - functional programming interface
 */
export const CustomObjectFieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomObjectFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new custom object field
         * @summary Create a new custom object field
         * @param {string} customObjectApiName 
         * @param {CreateCustomObjectsCustomObjectApiNameFieldsRequest} [createCustomObjectsCustomObjectApiNameFieldsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomObjectsCustomObjectApiNameFields(customObjectApiName: string, createCustomObjectsCustomObjectApiNameFieldsRequest?: CreateCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomObjectField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomObjectsCustomObjectApiNameFields(customObjectApiName, createCustomObjectsCustomObjectApiNameFieldsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectFieldsApi.createCustomObjectsCustomObjectApiNameFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a custom object field
         * @summary Delete a custom object field
         * @param {string} customObjectApiName 
         * @param {string} fieldApiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomObjectsCustomObjectApiNameFields(customObjectApiName: string, fieldApiName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomObjectsCustomObjectApiNameFields(customObjectApiName, fieldApiName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectFieldsApi.deleteCustomObjectsCustomObjectApiNameFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific custom object field
         * @summary Retrieve a specific custom object field
         * @param {string} customObjectApiName 
         * @param {string} fieldApiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomObjectsCustomObjectApiNameFields(customObjectApiName: string, fieldApiName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomObjectField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomObjectsCustomObjectApiNameFields(customObjectApiName, fieldApiName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectFieldsApi.getCustomObjectsCustomObjectApiNameFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of custom object fields  - Requires: `API Tier 1`
         * @summary List custom object fields
         * @param {string} customObjectApiName 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomObjectsCustomObjectApiNameFields(customObjectApiName: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCustomObjectsCustomObjectApiNameFields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomObjectsCustomObjectApiNameFields(customObjectApiName, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectFieldsApi.listCustomObjectsCustomObjectApiNameFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updated a specific custom object field
         * @summary Update a custom object field
         * @param {string} customObjectApiName 
         * @param {string} fieldApiName 
         * @param {UpdateCustomObjectsCustomObjectApiNameFieldsRequest} [updateCustomObjectsCustomObjectApiNameFieldsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomObjectsCustomObjectApiNameFields(customObjectApiName: string, fieldApiName: string, updateCustomObjectsCustomObjectApiNameFieldsRequest?: UpdateCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomObjectField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomObjectsCustomObjectApiNameFields(customObjectApiName, fieldApiName, updateCustomObjectsCustomObjectApiNameFieldsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectFieldsApi.updateCustomObjectsCustomObjectApiNameFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomObjectFieldsApi - factory interface
 */
export const CustomObjectFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomObjectFieldsApiFp(configuration)
    return {
        /**
         * Create a new custom object field
         * @summary Create a new custom object field
         * @param {CustomObjectFieldsApiCreateCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiCreateCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomObjectField> {
            return localVarFp.createCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.createCustomObjectsCustomObjectApiNameFieldsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a custom object field
         * @summary Delete a custom object field
         * @param {CustomObjectFieldsApiDeleteCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiDeleteCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.fieldApiName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific custom object field
         * @summary Retrieve a specific custom object field
         * @param {CustomObjectFieldsApiGetCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiGetCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomObjectField> {
            return localVarFp.getCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.fieldApiName, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of custom object fields  - Requires: `API Tier 1`
         * @summary List custom object fields
         * @param {CustomObjectFieldsApiListCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiListCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListCustomObjectsCustomObjectApiNameFields200Response> {
            return localVarFp.listCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Updated a specific custom object field
         * @summary Update a custom object field
         * @param {CustomObjectFieldsApiUpdateCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiUpdateCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomObjectField> {
            return localVarFp.updateCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.fieldApiName, requestParameters.updateCustomObjectsCustomObjectApiNameFieldsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCustomObjectsCustomObjectApiNameFields operation in CustomObjectFieldsApi.
 */
export interface CustomObjectFieldsApiCreateCustomObjectsCustomObjectApiNameFieldsRequest {
    readonly customObjectApiName: string

    readonly createCustomObjectsCustomObjectApiNameFieldsRequest?: CreateCustomObjectsCustomObjectApiNameFieldsRequest
}

/**
 * Request parameters for deleteCustomObjectsCustomObjectApiNameFields operation in CustomObjectFieldsApi.
 */
export interface CustomObjectFieldsApiDeleteCustomObjectsCustomObjectApiNameFieldsRequest {
    readonly customObjectApiName: string

    readonly fieldApiName: string
}

/**
 * Request parameters for getCustomObjectsCustomObjectApiNameFields operation in CustomObjectFieldsApi.
 */
export interface CustomObjectFieldsApiGetCustomObjectsCustomObjectApiNameFieldsRequest {
    readonly customObjectApiName: string

    readonly fieldApiName: string
}

/**
 * Request parameters for listCustomObjectsCustomObjectApiNameFields operation in CustomObjectFieldsApi.
 */
export interface CustomObjectFieldsApiListCustomObjectsCustomObjectApiNameFieldsRequest {
    readonly customObjectApiName: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for updateCustomObjectsCustomObjectApiNameFields operation in CustomObjectFieldsApi.
 */
export interface CustomObjectFieldsApiUpdateCustomObjectsCustomObjectApiNameFieldsRequest {
    readonly customObjectApiName: string

    readonly fieldApiName: string

    readonly updateCustomObjectsCustomObjectApiNameFieldsRequest?: UpdateCustomObjectsCustomObjectApiNameFieldsRequest
}

/**
 * CustomObjectFieldsApi - object-oriented interface
 */
export class CustomObjectFieldsApi extends BaseAPI {
    /**
     * Create a new custom object field
     * @summary Create a new custom object field
     * @param {CustomObjectFieldsApiCreateCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiCreateCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectFieldsApiFp(this.configuration).createCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.createCustomObjectsCustomObjectApiNameFieldsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a custom object field
     * @summary Delete a custom object field
     * @param {CustomObjectFieldsApiDeleteCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiDeleteCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectFieldsApiFp(this.configuration).deleteCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.fieldApiName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific custom object field
     * @summary Retrieve a specific custom object field
     * @param {CustomObjectFieldsApiGetCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiGetCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectFieldsApiFp(this.configuration).getCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.fieldApiName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of custom object fields  - Requires: `API Tier 1`
     * @summary List custom object fields
     * @param {CustomObjectFieldsApiListCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiListCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectFieldsApiFp(this.configuration).listCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updated a specific custom object field
     * @summary Update a custom object field
     * @param {CustomObjectFieldsApiUpdateCustomObjectsCustomObjectApiNameFieldsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCustomObjectsCustomObjectApiNameFields(requestParameters: CustomObjectFieldsApiUpdateCustomObjectsCustomObjectApiNameFieldsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectFieldsApiFp(this.configuration).updateCustomObjectsCustomObjectApiNameFields(requestParameters.customObjectApiName, requestParameters.fieldApiName, requestParameters.updateCustomObjectsCustomObjectApiNameFieldsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomObjectRecordsApi - axios parameter creator
 */
export const CustomObjectRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * bulk create new custom object records
         * @summary Bulk Create custom object records
         * @param {string} customObjectApiName 
         * @param {BulkCreateCustomObjectsCustomObjectApiNameRecordsRequest} [bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest?: BulkCreateCustomObjectsCustomObjectApiNameRecordsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('bulkCreateCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/bulk/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk Delete custom object records
         * @summary Bulk delete custom object records
         * @param {string} customObjectApiName 
         * @param {BulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest} [bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest?: BulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('bulkDeleteCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/bulk-delete/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk Updated a specific custom object records
         * @summary Bulk Update custom object records
         * @param {string} customObjectApiName 
         * @param {BulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest} [bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest?: BulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('bulkUpdateCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/bulk/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new custom object record
         * @summary Create a new custom object record
         * @param {string} customObjectApiName 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, requestBody?: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('createCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a custom object record
         * @param {string} customObjectApiName 
         * @param {string} codrId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, codrId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('deleteCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            // verify required parameter 'codrId' is not null or undefined
            assertParamExists('deleteCustomObjectsCustomObjectApiNameRecords', 'codrId', codrId)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/{codr_id}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)))
                .replace(`{${"codr_id"}}`, encodeURIComponent(String(codrId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific custom object record
         * @summary Retrieve a specific custom object record
         * @param {string} customObjectApiName 
         * @param {string} codrId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, codrId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('getCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            // verify required parameter 'codrId' is not null or undefined
            assertParamExists('getCustomObjectsCustomObjectApiNameRecords', 'codrId', codrId)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/{codr_id}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)))
                .replace(`{${"codr_id"}}`, encodeURIComponent(String(codrId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific custom object record by its external_id
         * @summary Retrieve a specific custom object record by its external_id
         * @param {string} customObjectApiName 
         * @param {string} externalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomObjectsCustomObjectApiNameRecordsByExternalId: async (customObjectApiName: string, externalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('getCustomObjectsCustomObjectApiNameRecordsByExternalId', 'customObjectApiName', customObjectApiName)
            // verify required parameter 'externalId' is not null or undefined
            assertParamExists('getCustomObjectsCustomObjectApiNameRecordsByExternalId', 'externalId', externalId)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/external_id/{external_id}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)))
                .replace(`{${"external_id"}}`, encodeURIComponent(String(externalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of custom object records filtered by querying
         * @summary List custom object records by query
         * @param {string} customObjectApiName 
         * @param {ListByQueryCustomObjectsCustomObjectApiNameRecordsRequest} [listByQueryCustomObjectsCustomObjectApiNameRecordsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByQueryCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, listByQueryCustomObjectsCustomObjectApiNameRecordsRequest?: ListByQueryCustomObjectsCustomObjectApiNameRecordsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('listByQueryCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/query/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listByQueryCustomObjectsCustomObjectApiNameRecordsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of custom object records  - Requires: `API Tier 1`
         * @summary List custom object records
         * @param {string} customObjectApiName 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('listCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updated a specific custom object record
         * @summary Update a custom object record
         * @param {string} customObjectApiName 
         * @param {string} codrId 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomObjectsCustomObjectApiNameRecords: async (customObjectApiName: string, codrId: string, requestBody?: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('updateCustomObjectsCustomObjectApiNameRecords', 'customObjectApiName', customObjectApiName)
            // verify required parameter 'codrId' is not null or undefined
            assertParamExists('updateCustomObjectsCustomObjectApiNameRecords', 'codrId', codrId)
            const localVarPath = `/custom-objects/{custom_object_api_name}/records/{codr_id}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)))
                .replace(`{${"codr_id"}}`, encodeURIComponent(String(codrId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomObjectRecordsApi - functional programming interface
 */
export const CustomObjectRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomObjectRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * bulk create new custom object records
         * @summary Bulk Create custom object records
         * @param {string} customObjectApiName 
         * @param {BulkCreateCustomObjectsCustomObjectApiNameRecordsRequest} [bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreateCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest?: BulkCreateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkCreateCustomObjectsCustomObjectApiNameRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateCustomObjectsCustomObjectApiNameRecords(customObjectApiName, bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.bulkCreateCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk Delete custom object records
         * @summary Bulk delete custom object records
         * @param {string} customObjectApiName 
         * @param {BulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest} [bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest?: BulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteCustomObjectsCustomObjectApiNameRecords(customObjectApiName, bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.bulkDeleteCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk Updated a specific custom object records
         * @summary Bulk Update custom object records
         * @param {string} customObjectApiName 
         * @param {BulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest} [bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest?: BulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkCreateCustomObjectsCustomObjectApiNameRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateCustomObjectsCustomObjectApiNameRecords(customObjectApiName, bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.bulkUpdateCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new custom object record
         * @summary Create a new custom object record
         * @param {string} customObjectApiName 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomObjectsCustomObjectApiNameRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomObjectsCustomObjectApiNameRecords(customObjectApiName, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.createCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a custom object record
         * @param {string} customObjectApiName 
         * @param {string} codrId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, codrId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomObjectsCustomObjectApiNameRecords(customObjectApiName, codrId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.deleteCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific custom object record
         * @summary Retrieve a specific custom object record
         * @param {string} customObjectApiName 
         * @param {string} codrId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, codrId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomObjectDataRow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomObjectsCustomObjectApiNameRecords(customObjectApiName, codrId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.getCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific custom object record by its external_id
         * @summary Retrieve a specific custom object record by its external_id
         * @param {string} customObjectApiName 
         * @param {string} externalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomObjectsCustomObjectApiNameRecordsByExternalId(customObjectApiName: string, externalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomObjectDataRow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomObjectsCustomObjectApiNameRecordsByExternalId(customObjectApiName, externalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.getCustomObjectsCustomObjectApiNameRecordsByExternalId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of custom object records filtered by querying
         * @summary List custom object records by query
         * @param {string} customObjectApiName 
         * @param {ListByQueryCustomObjectsCustomObjectApiNameRecordsRequest} [listByQueryCustomObjectsCustomObjectApiNameRecordsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listByQueryCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, listByQueryCustomObjectsCustomObjectApiNameRecordsRequest?: ListByQueryCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListByQueryCustomObjectsCustomObjectApiNameRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listByQueryCustomObjectsCustomObjectApiNameRecords(customObjectApiName, listByQueryCustomObjectsCustomObjectApiNameRecordsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.listByQueryCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of custom object records  - Requires: `API Tier 1`
         * @summary List custom object records
         * @param {string} customObjectApiName 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCustomObjectsCustomObjectApiNameRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomObjectsCustomObjectApiNameRecords(customObjectApiName, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.listCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updated a specific custom object record
         * @summary Update a custom object record
         * @param {string} customObjectApiName 
         * @param {string} codrId 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomObjectsCustomObjectApiNameRecords(customObjectApiName: string, codrId: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomObjectsCustomObjectApiNameRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomObjectsCustomObjectApiNameRecords(customObjectApiName, codrId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectRecordsApi.updateCustomObjectsCustomObjectApiNameRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomObjectRecordsApi - factory interface
 */
export const CustomObjectRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomObjectRecordsApiFp(configuration)
    return {
        /**
         * bulk create new custom object records
         * @summary Bulk Create custom object records
         * @param {CustomObjectRecordsApiBulkCreateCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiBulkCreateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkCreateCustomObjectsCustomObjectApiNameRecords200Response> {
            return localVarFp.bulkCreateCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk Delete custom object records
         * @summary Bulk delete custom object records
         * @param {CustomObjectRecordsApiBulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiBulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bulkDeleteCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk Updated a specific custom object records
         * @summary Bulk Update custom object records
         * @param {CustomObjectRecordsApiBulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiBulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkCreateCustomObjectsCustomObjectApiNameRecords200Response> {
            return localVarFp.bulkUpdateCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new custom object record
         * @summary Create a new custom object record
         * @param {CustomObjectRecordsApiCreateCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiCreateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCustomObjectsCustomObjectApiNameRecords200Response> {
            return localVarFp.createCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a custom object record
         * @param {CustomObjectRecordsApiDeleteCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.codrId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific custom object record
         * @summary Retrieve a specific custom object record
         * @param {CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomObjectDataRow> {
            return localVarFp.getCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.codrId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific custom object record by its external_id
         * @summary Retrieve a specific custom object record by its external_id
         * @param {CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsByExternalIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomObjectsCustomObjectApiNameRecordsByExternalId(requestParameters: CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsByExternalIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomObjectDataRow> {
            return localVarFp.getCustomObjectsCustomObjectApiNameRecordsByExternalId(requestParameters.customObjectApiName, requestParameters.externalId, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of custom object records filtered by querying
         * @summary List custom object records by query
         * @param {CustomObjectRecordsApiListByQueryCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listByQueryCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiListByQueryCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListByQueryCustomObjectsCustomObjectApiNameRecords200Response> {
            return localVarFp.listByQueryCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.listByQueryCustomObjectsCustomObjectApiNameRecordsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of custom object records  - Requires: `API Tier 1`
         * @summary List custom object records
         * @param {CustomObjectRecordsApiListCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiListCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListCustomObjectsCustomObjectApiNameRecords200Response> {
            return localVarFp.listCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Updated a specific custom object record
         * @summary Update a custom object record
         * @param {CustomObjectRecordsApiUpdateCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCustomObjectsCustomObjectApiNameRecords200Response> {
            return localVarFp.updateCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.codrId, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkCreateCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiBulkCreateCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    readonly bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest?: BulkCreateCustomObjectsCustomObjectApiNameRecordsRequest
}

/**
 * Request parameters for bulkDeleteCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiBulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    readonly bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest?: BulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest
}

/**
 * Request parameters for bulkUpdateCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiBulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    readonly bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest?: BulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest
}

/**
 * Request parameters for createCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiCreateCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for deleteCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiDeleteCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    readonly codrId: string
}

/**
 * Request parameters for getCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    readonly codrId: string
}

/**
 * Request parameters for getCustomObjectsCustomObjectApiNameRecordsByExternalId operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsByExternalIdRequest {
    readonly customObjectApiName: string

    readonly externalId: string
}

/**
 * Request parameters for listByQueryCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiListByQueryCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    readonly listByQueryCustomObjectsCustomObjectApiNameRecordsRequest?: ListByQueryCustomObjectsCustomObjectApiNameRecordsRequest
}

/**
 * Request parameters for listCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiListCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for updateCustomObjectsCustomObjectApiNameRecords operation in CustomObjectRecordsApi.
 */
export interface CustomObjectRecordsApiUpdateCustomObjectsCustomObjectApiNameRecordsRequest {
    readonly customObjectApiName: string

    readonly codrId: string

    readonly requestBody?: { [key: string]: any; }
}

/**
 * CustomObjectRecordsApi - object-oriented interface
 */
export class CustomObjectRecordsApi extends BaseAPI {
    /**
     * bulk create new custom object records
     * @summary Bulk Create custom object records
     * @param {CustomObjectRecordsApiBulkCreateCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bulkCreateCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiBulkCreateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).bulkCreateCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.bulkCreateCustomObjectsCustomObjectApiNameRecordsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk Delete custom object records
     * @summary Bulk delete custom object records
     * @param {CustomObjectRecordsApiBulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bulkDeleteCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiBulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).bulkDeleteCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.bulkDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk Updated a specific custom object records
     * @summary Bulk Update custom object records
     * @param {CustomObjectRecordsApiBulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bulkUpdateCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiBulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).bulkUpdateCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.bulkUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new custom object record
     * @summary Create a new custom object record
     * @param {CustomObjectRecordsApiCreateCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiCreateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).createCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a custom object record
     * @param {CustomObjectRecordsApiDeleteCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiDeleteCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).deleteCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.codrId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific custom object record
     * @summary Retrieve a specific custom object record
     * @param {CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).getCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.codrId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific custom object record by its external_id
     * @summary Retrieve a specific custom object record by its external_id
     * @param {CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsByExternalIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomObjectsCustomObjectApiNameRecordsByExternalId(requestParameters: CustomObjectRecordsApiGetCustomObjectsCustomObjectApiNameRecordsByExternalIdRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).getCustomObjectsCustomObjectApiNameRecordsByExternalId(requestParameters.customObjectApiName, requestParameters.externalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of custom object records filtered by querying
     * @summary List custom object records by query
     * @param {CustomObjectRecordsApiListByQueryCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listByQueryCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiListByQueryCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).listByQueryCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.listByQueryCustomObjectsCustomObjectApiNameRecordsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of custom object records  - Requires: `API Tier 1`
     * @summary List custom object records
     * @param {CustomObjectRecordsApiListCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiListCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).listCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updated a specific custom object record
     * @summary Update a custom object record
     * @param {CustomObjectRecordsApiUpdateCustomObjectsCustomObjectApiNameRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCustomObjectsCustomObjectApiNameRecords(requestParameters: CustomObjectRecordsApiUpdateCustomObjectsCustomObjectApiNameRecordsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectRecordsApiFp(this.configuration).updateCustomObjectsCustomObjectApiNameRecords(requestParameters.customObjectApiName, requestParameters.codrId, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomObjectsApi - axios parameter creator
 */
export const CustomObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new custom object
         * @summary Create a new custom object
         * @param {CreateCustomObjectsRequest} [createCustomObjectsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomObjects: async (createCustomObjectsRequest?: CreateCustomObjectsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/custom-objects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomObjectsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a custom object
         * @param {string} customObjectApiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomObjects: async (customObjectApiName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('deleteCustomObjects', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific custom object
         * @summary Retrieve a specific custom object
         * @param {string} customObjectApiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomObjects: async (customObjectApiName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('getCustomObjects', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read", "custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of custom objects  - Requires: `API Tier 1`
         * @summary List custom objects
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomObjects: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/custom-objects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read", "custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updated a specific custom object
         * @summary Update a custom object
         * @param {string} customObjectApiName 
         * @param {UpdateCustomObjectsRequest} [updateCustomObjectsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomObjects: async (customObjectApiName: string, updateCustomObjectsRequest?: UpdateCustomObjectsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customObjectApiName' is not null or undefined
            assertParamExists('updateCustomObjects', 'customObjectApiName', customObjectApiName)
            const localVarPath = `/custom-objects/{custom_object_api_name}/`
                .replace(`{${"custom_object_api_name"}}`, encodeURIComponent(String(customObjectApiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomObjectsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomObjectsApi - functional programming interface
 */
export const CustomObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new custom object
         * @summary Create a new custom object
         * @param {CreateCustomObjectsRequest} [createCustomObjectsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomObjects(createCustomObjectsRequest?: CreateCustomObjectsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomObjects(createCustomObjectsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectsApi.createCustomObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a custom object
         * @param {string} customObjectApiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomObjects(customObjectApiName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomObjects(customObjectApiName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectsApi.deleteCustomObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific custom object
         * @summary Retrieve a specific custom object
         * @param {string} customObjectApiName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomObjects(customObjectApiName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomObjects(customObjectApiName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectsApi.getCustomObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of custom objects  - Requires: `API Tier 1`
         * @summary List custom objects
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomObjects(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCustomObjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomObjects(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectsApi.listCustomObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updated a specific custom object
         * @summary Update a custom object
         * @param {string} customObjectApiName 
         * @param {UpdateCustomObjectsRequest} [updateCustomObjectsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomObjects(customObjectApiName: string, updateCustomObjectsRequest?: UpdateCustomObjectsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomObjects(customObjectApiName, updateCustomObjectsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomObjectsApi.updateCustomObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomObjectsApi - factory interface
 */
export const CustomObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomObjectsApiFp(configuration)
    return {
        /**
         * Create a new custom object
         * @summary Create a new custom object
         * @param {CustomObjectsApiCreateCustomObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomObjects(requestParameters: CustomObjectsApiCreateCustomObjectsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CustomObject> {
            return localVarFp.createCustomObjects(requestParameters.createCustomObjectsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a custom object
         * @param {CustomObjectsApiDeleteCustomObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomObjects(requestParameters: CustomObjectsApiDeleteCustomObjectsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCustomObjects(requestParameters.customObjectApiName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific custom object
         * @summary Retrieve a specific custom object
         * @param {CustomObjectsApiGetCustomObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomObjects(requestParameters: CustomObjectsApiGetCustomObjectsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomObject> {
            return localVarFp.getCustomObjects(requestParameters.customObjectApiName, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of custom objects  - Requires: `API Tier 1`
         * @summary List custom objects
         * @param {CustomObjectsApiListCustomObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomObjects(requestParameters: CustomObjectsApiListCustomObjectsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListCustomObjects200Response> {
            return localVarFp.listCustomObjects(requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Updated a specific custom object
         * @summary Update a custom object
         * @param {CustomObjectsApiUpdateCustomObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomObjects(requestParameters: CustomObjectsApiUpdateCustomObjectsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomObject> {
            return localVarFp.updateCustomObjects(requestParameters.customObjectApiName, requestParameters.updateCustomObjectsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCustomObjects operation in CustomObjectsApi.
 */
export interface CustomObjectsApiCreateCustomObjectsRequest {
    readonly createCustomObjectsRequest?: CreateCustomObjectsRequest
}

/**
 * Request parameters for deleteCustomObjects operation in CustomObjectsApi.
 */
export interface CustomObjectsApiDeleteCustomObjectsRequest {
    readonly customObjectApiName: string
}

/**
 * Request parameters for getCustomObjects operation in CustomObjectsApi.
 */
export interface CustomObjectsApiGetCustomObjectsRequest {
    readonly customObjectApiName: string
}

/**
 * Request parameters for listCustomObjects operation in CustomObjectsApi.
 */
export interface CustomObjectsApiListCustomObjectsRequest {
    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for updateCustomObjects operation in CustomObjectsApi.
 */
export interface CustomObjectsApiUpdateCustomObjectsRequest {
    readonly customObjectApiName: string

    readonly updateCustomObjectsRequest?: UpdateCustomObjectsRequest
}

/**
 * CustomObjectsApi - object-oriented interface
 */
export class CustomObjectsApi extends BaseAPI {
    /**
     * Create a new custom object
     * @summary Create a new custom object
     * @param {CustomObjectsApiCreateCustomObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCustomObjects(requestParameters: CustomObjectsApiCreateCustomObjectsRequest = {}, options?: RawAxiosRequestConfig) {
        return CustomObjectsApiFp(this.configuration).createCustomObjects(requestParameters.createCustomObjectsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a custom object
     * @param {CustomObjectsApiDeleteCustomObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCustomObjects(requestParameters: CustomObjectsApiDeleteCustomObjectsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectsApiFp(this.configuration).deleteCustomObjects(requestParameters.customObjectApiName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific custom object
     * @summary Retrieve a specific custom object
     * @param {CustomObjectsApiGetCustomObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomObjects(requestParameters: CustomObjectsApiGetCustomObjectsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectsApiFp(this.configuration).getCustomObjects(requestParameters.customObjectApiName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of custom objects  - Requires: `API Tier 1`
     * @summary List custom objects
     * @param {CustomObjectsApiListCustomObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCustomObjects(requestParameters: CustomObjectsApiListCustomObjectsRequest = {}, options?: RawAxiosRequestConfig) {
        return CustomObjectsApiFp(this.configuration).listCustomObjects(requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updated a specific custom object
     * @summary Update a custom object
     * @param {CustomObjectsApiUpdateCustomObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCustomObjects(requestParameters: CustomObjectsApiUpdateCustomObjectsRequest, options?: RawAxiosRequestConfig) {
        return CustomObjectsApiFp(this.configuration).updateCustomObjects(requestParameters.customObjectApiName, requestParameters.updateCustomObjectsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepartmentsApi - axios parameter creator
 */
export const DepartmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific department
         * @summary Retrieve a specific department
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartments: async (id: string, expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDepartments', 'id', id)
            const localVarPath = `/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["departments.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of departments  - Requires: `API Tier 1`  - Expandable fields: `parent`, `department_hierarchy`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List departments
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDepartments: async (expand?: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["departments.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentsApi - functional programming interface
 */
export const DepartmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepartmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific department
         * @summary Retrieve a specific department
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepartments(id: string, expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDepartments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartments(id, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.getDepartments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of departments  - Requires: `API Tier 1`  - Expandable fields: `parent`, `department_hierarchy`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List departments
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDepartments(expand?: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDepartments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDepartments(expand, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsApi.listDepartments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DepartmentsApi - factory interface
 */
export const DepartmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepartmentsApiFp(configuration)
    return {
        /**
         * Retrieve a specific department
         * @summary Retrieve a specific department
         * @param {DepartmentsApiGetDepartmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepartments(requestParameters: DepartmentsApiGetDepartmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetDepartments200Response> {
            return localVarFp.getDepartments(requestParameters.id, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of departments  - Requires: `API Tier 1`  - Expandable fields: `parent`, `department_hierarchy`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List departments
         * @param {DepartmentsApiListDepartmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDepartments(requestParameters: DepartmentsApiListDepartmentsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListDepartments200Response> {
            return localVarFp.listDepartments(requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDepartments operation in DepartmentsApi.
 */
export interface DepartmentsApiGetDepartmentsRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string

    readonly expand?: string
}

/**
 * Request parameters for listDepartments operation in DepartmentsApi.
 */
export interface DepartmentsApiListDepartmentsRequest {
    readonly expand?: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * DepartmentsApi - object-oriented interface
 */
export class DepartmentsApi extends BaseAPI {
    /**
     * Retrieve a specific department
     * @summary Retrieve a specific department
     * @param {DepartmentsApiGetDepartmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDepartments(requestParameters: DepartmentsApiGetDepartmentsRequest, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).getDepartments(requestParameters.id, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of departments  - Requires: `API Tier 1`  - Expandable fields: `parent`, `department_hierarchy`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List departments
     * @param {DepartmentsApiListDepartmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDepartments(requestParameters: DepartmentsApiListDepartmentsRequest = {}, options?: RawAxiosRequestConfig) {
        return DepartmentsApiFp(this.configuration).listDepartments(requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DraftHiresApi - axios parameter creator
 */
export const DraftHiresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create bulk draft hire
         * @summary Create bulk draft hire
         * @param {BulkDraftHireRequest} [bulkDraftHireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDraftHires: async (bulkDraftHireRequest?: BulkDraftHireRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/draft-hires/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["draft-hires.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDraftHireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DraftHiresApi - functional programming interface
 */
export const DraftHiresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DraftHiresApiAxiosParamCreator(configuration)
    return {
        /**
         * Create bulk draft hire
         * @summary Create bulk draft hire
         * @param {BulkDraftHireRequest} [bulkDraftHireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDraftHires(bulkDraftHireRequest?: BulkDraftHireRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBulkDraftHireResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDraftHires(bulkDraftHireRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DraftHiresApi.createDraftHires']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DraftHiresApi - factory interface
 */
export const DraftHiresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DraftHiresApiFp(configuration)
    return {
        /**
         * Create bulk draft hire
         * @summary Create bulk draft hire
         * @param {DraftHiresApiCreateDraftHiresRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDraftHires(requestParameters: DraftHiresApiCreateDraftHiresRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateBulkDraftHireResponse> {
            return localVarFp.createDraftHires(requestParameters.bulkDraftHireRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDraftHires operation in DraftHiresApi.
 */
export interface DraftHiresApiCreateDraftHiresRequest {
    readonly bulkDraftHireRequest?: BulkDraftHireRequest
}

/**
 * DraftHiresApi - object-oriented interface
 */
export class DraftHiresApi extends BaseAPI {
    /**
     * Create bulk draft hire
     * @summary Create bulk draft hire
     * @param {DraftHiresApiCreateDraftHiresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDraftHires(requestParameters: DraftHiresApiCreateDraftHiresRequest = {}, options?: RawAxiosRequestConfig) {
        return DraftHiresApiFp(this.configuration).createDraftHires(requestParameters.bulkDraftHireRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmploymentTypesApi - axios parameter creator
 */
export const EmploymentTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific employment type
         * @summary Retrieve a specific employment type
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmploymentTypes: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEmploymentTypes', 'id', id)
            const localVarPath = `/employment-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["employment-types.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of employment types  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List employment types
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmploymentTypes: async (orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employment-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["employment-types.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmploymentTypesApi - functional programming interface
 */
export const EmploymentTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmploymentTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific employment type
         * @summary Retrieve a specific employment type
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmploymentTypes(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEmploymentTypes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmploymentTypes(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmploymentTypesApi.getEmploymentTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of employment types  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List employment types
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEmploymentTypes(orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEmploymentTypes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEmploymentTypes(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmploymentTypesApi.listEmploymentTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmploymentTypesApi - factory interface
 */
export const EmploymentTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmploymentTypesApiFp(configuration)
    return {
        /**
         * Retrieve a specific employment type
         * @summary Retrieve a specific employment type
         * @param {EmploymentTypesApiGetEmploymentTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmploymentTypes(requestParameters: EmploymentTypesApiGetEmploymentTypesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetEmploymentTypes200Response> {
            return localVarFp.getEmploymentTypes(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of employment types  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List employment types
         * @param {EmploymentTypesApiListEmploymentTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmploymentTypes(requestParameters: EmploymentTypesApiListEmploymentTypesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListEmploymentTypes200Response> {
            return localVarFp.listEmploymentTypes(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEmploymentTypes operation in EmploymentTypesApi.
 */
export interface EmploymentTypesApiGetEmploymentTypesRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string
}

/**
 * Request parameters for listEmploymentTypes operation in EmploymentTypesApi.
 */
export interface EmploymentTypesApiListEmploymentTypesRequest {
    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * EmploymentTypesApi - object-oriented interface
 */
export class EmploymentTypesApi extends BaseAPI {
    /**
     * Retrieve a specific employment type
     * @summary Retrieve a specific employment type
     * @param {EmploymentTypesApiGetEmploymentTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getEmploymentTypes(requestParameters: EmploymentTypesApiGetEmploymentTypesRequest, options?: RawAxiosRequestConfig) {
        return EmploymentTypesApiFp(this.configuration).getEmploymentTypes(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of employment types  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List employment types
     * @param {EmploymentTypesApiListEmploymentTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listEmploymentTypes(requestParameters: EmploymentTypesApiListEmploymentTypesRequest = {}, options?: RawAxiosRequestConfig) {
        return EmploymentTypesApiFp(this.configuration).listEmploymentTypes(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntitlementsApi - axios parameter creator
 */
export const EntitlementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A List of entitlements  - Requires: `API Tier 1`
         * @summary List entitlements
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntitlements: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitlementsApi - functional programming interface
 */
export const EntitlementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitlementsApiAxiosParamCreator(configuration)
    return {
        /**
         * A List of entitlements  - Requires: `API Tier 1`
         * @summary List entitlements
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEntitlements(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEntitlements200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEntitlements(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitlementsApi.listEntitlements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntitlementsApi - factory interface
 */
export const EntitlementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitlementsApiFp(configuration)
    return {
        /**
         * A List of entitlements  - Requires: `API Tier 1`
         * @summary List entitlements
         * @param {EntitlementsApiListEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEntitlements(requestParameters: EntitlementsApiListEntitlementsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListEntitlements200Response> {
            return localVarFp.listEntitlements(requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listEntitlements operation in EntitlementsApi.
 */
export interface EntitlementsApiListEntitlementsRequest {
    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * EntitlementsApi - object-oriented interface
 */
export class EntitlementsApi extends BaseAPI {
    /**
     * A List of entitlements  - Requires: `API Tier 1`
     * @summary List entitlements
     * @param {EntitlementsApiListEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listEntitlements(requestParameters: EntitlementsApiListEntitlementsRequest = {}, options?: RawAxiosRequestConfig) {
        return EntitlementsApiFp(this.configuration).listEntitlements(requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobFunctionsApi - axios parameter creator
 */
export const JobFunctionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific job function
         * @summary Retrieve a specific job function
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobFunctions: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getJobFunctions', 'id', id)
            const localVarPath = `/job-functions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["job-functions.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of job functions  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List job functions
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobFunctions: async (orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/job-functions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["job-functions.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobFunctionsApi - functional programming interface
 */
export const JobFunctionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobFunctionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific job function
         * @summary Retrieve a specific job function
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobFunctions(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJobFunctions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobFunctions(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobFunctionsApi.getJobFunctions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of job functions  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List job functions
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobFunctions(orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListJobFunctions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobFunctions(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobFunctionsApi.listJobFunctions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobFunctionsApi - factory interface
 */
export const JobFunctionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobFunctionsApiFp(configuration)
    return {
        /**
         * Retrieve a specific job function
         * @summary Retrieve a specific job function
         * @param {JobFunctionsApiGetJobFunctionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobFunctions(requestParameters: JobFunctionsApiGetJobFunctionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetJobFunctions200Response> {
            return localVarFp.getJobFunctions(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of job functions  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List job functions
         * @param {JobFunctionsApiListJobFunctionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobFunctions(requestParameters: JobFunctionsApiListJobFunctionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListJobFunctions200Response> {
            return localVarFp.listJobFunctions(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getJobFunctions operation in JobFunctionsApi.
 */
export interface JobFunctionsApiGetJobFunctionsRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string
}

/**
 * Request parameters for listJobFunctions operation in JobFunctionsApi.
 */
export interface JobFunctionsApiListJobFunctionsRequest {
    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * JobFunctionsApi - object-oriented interface
 */
export class JobFunctionsApi extends BaseAPI {
    /**
     * Retrieve a specific job function
     * @summary Retrieve a specific job function
     * @param {JobFunctionsApiGetJobFunctionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJobFunctions(requestParameters: JobFunctionsApiGetJobFunctionsRequest, options?: RawAxiosRequestConfig) {
        return JobFunctionsApiFp(this.configuration).getJobFunctions(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of job functions  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List job functions
     * @param {JobFunctionsApiListJobFunctionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listJobFunctions(requestParameters: JobFunctionsApiListJobFunctionsRequest = {}, options?: RawAxiosRequestConfig) {
        return JobFunctionsApiFp(this.configuration).listJobFunctions(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LeaveAccrualsApi - axios parameter creator
 */
export const LeaveAccrualsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new leave accrual
         * @summary Create a new leave accrual
         * @param {LeaveAccrualRequest} [leaveAccrualRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaveAccruals: async (leaveAccrualRequest?: LeaveAccrualRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/leave-accruals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["leave-accruals.read", "leave-accruals.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leaveAccrualRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific leave accrual
         * @summary Retrieve a specific leave accrual
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaveAccruals: async (id: string, expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLeaveAccruals', 'id', id)
            const localVarPath = `/leave-accruals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["leave-accruals.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaveAccrualsApi - functional programming interface
 */
export const LeaveAccrualsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaveAccrualsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new leave accrual
         * @summary Create a new leave accrual
         * @param {LeaveAccrualRequest} [leaveAccrualRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeaveAccruals(leaveAccrualRequest?: LeaveAccrualRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaveAccrual>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeaveAccruals(leaveAccrualRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaveAccrualsApi.createLeaveAccruals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific leave accrual
         * @summary Retrieve a specific leave accrual
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeaveAccruals(id: string, expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLeaveAccruals200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeaveAccruals(id, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaveAccrualsApi.getLeaveAccruals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeaveAccrualsApi - factory interface
 */
export const LeaveAccrualsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaveAccrualsApiFp(configuration)
    return {
        /**
         * Create a new leave accrual
         * @summary Create a new leave accrual
         * @param {LeaveAccrualsApiCreateLeaveAccrualsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaveAccruals(requestParameters: LeaveAccrualsApiCreateLeaveAccrualsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<LeaveAccrual> {
            return localVarFp.createLeaveAccruals(requestParameters.leaveAccrualRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific leave accrual
         * @summary Retrieve a specific leave accrual
         * @param {LeaveAccrualsApiGetLeaveAccrualsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaveAccruals(requestParameters: LeaveAccrualsApiGetLeaveAccrualsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLeaveAccruals200Response> {
            return localVarFp.getLeaveAccruals(requestParameters.id, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLeaveAccruals operation in LeaveAccrualsApi.
 */
export interface LeaveAccrualsApiCreateLeaveAccrualsRequest {
    readonly leaveAccrualRequest?: LeaveAccrualRequest
}

/**
 * Request parameters for getLeaveAccruals operation in LeaveAccrualsApi.
 */
export interface LeaveAccrualsApiGetLeaveAccrualsRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string

    readonly expand?: string
}

/**
 * LeaveAccrualsApi - object-oriented interface
 */
export class LeaveAccrualsApi extends BaseAPI {
    /**
     * Create a new leave accrual
     * @summary Create a new leave accrual
     * @param {LeaveAccrualsApiCreateLeaveAccrualsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createLeaveAccruals(requestParameters: LeaveAccrualsApiCreateLeaveAccrualsRequest = {}, options?: RawAxiosRequestConfig) {
        return LeaveAccrualsApiFp(this.configuration).createLeaveAccruals(requestParameters.leaveAccrualRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific leave accrual
     * @summary Retrieve a specific leave accrual
     * @param {LeaveAccrualsApiGetLeaveAccrualsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLeaveAccruals(requestParameters: LeaveAccrualsApiGetLeaveAccrualsRequest, options?: RawAxiosRequestConfig) {
        return LeaveAccrualsApiFp(this.configuration).getLeaveAccruals(requestParameters.id, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeApi - axios parameter creator
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * SSO information of the current user  - Requires: `API Tier 1`  - Expandable fields: `company`
         * @summary Retrieve my SSO information
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSsoMe: async (expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sso-me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["sso-me.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * SSO information of the current user  - Requires: `API Tier 1`  - Expandable fields: `company`
         * @summary Retrieve my SSO information
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSsoMe(expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSOMe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSsoMe(expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.listSsoMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeApi - factory interface
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * SSO information of the current user  - Requires: `API Tier 1`  - Expandable fields: `company`
         * @summary Retrieve my SSO information
         * @param {MeApiListSsoMeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSsoMe(requestParameters: MeApiListSsoMeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SSOMe> {
            return localVarFp.listSsoMe(requestParameters.expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listSsoMe operation in MeApi.
 */
export interface MeApiListSsoMeRequest {
    readonly expand?: string
}

/**
 * MeApi - object-oriented interface
 */
export class MeApi extends BaseAPI {
    /**
     * SSO information of the current user  - Requires: `API Tier 1`  - Expandable fields: `company`
     * @summary Retrieve my SSO information
     * @param {MeApiListSsoMeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSsoMe(requestParameters: MeApiListSsoMeRequest = {}, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).listSsoMe(requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ObjectCategoriesApi - axios parameter creator
 */
export const ObjectCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new object category
         * @summary Create a new object category
         * @param {CreateObjectCategoriesRequest} [createObjectCategoriesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjectCategories: async (createObjectCategoriesRequest?: CreateObjectCategoriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/object-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", [], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createObjectCategoriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a object category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectCategories: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteObjectCategories', 'id', id)
            const localVarPath = `/object-categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific object category
         * @summary Retrieve a specific object category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectCategories: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getObjectCategories', 'id', id)
            const localVarPath = `/object-categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read", "custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of object categories  - Requires: `API Tier 1`
         * @summary List object categories
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjectCategories: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/object-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read", "custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updated a specific object category
         * @summary Update a object category
         * @param {string} id 
         * @param {CreateObjectCategoriesRequest} [createObjectCategoriesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectCategories: async (id: string, createObjectCategoriesRequest?: CreateObjectCategoriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateObjectCategories', 'id', id)
            const localVarPath = `/object-categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["custom-objects.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createObjectCategoriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectCategoriesApi - functional programming interface
 */
export const ObjectCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObjectCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new object category
         * @summary Create a new object category
         * @param {CreateObjectCategoriesRequest} [createObjectCategoriesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createObjectCategories(createObjectCategoriesRequest?: CreateObjectCategoriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createObjectCategories(createObjectCategoriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectCategoriesApi.createObjectCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a object category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteObjectCategories(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteObjectCategories(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectCategoriesApi.deleteObjectCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific object category
         * @summary Retrieve a specific object category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectCategories(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectCategories(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectCategoriesApi.getObjectCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of object categories  - Requires: `API Tier 1`
         * @summary List object categories
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listObjectCategories(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListObjectCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listObjectCategories(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectCategoriesApi.listObjectCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updated a specific object category
         * @summary Update a object category
         * @param {string} id 
         * @param {CreateObjectCategoriesRequest} [createObjectCategoriesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateObjectCategories(id: string, createObjectCategoriesRequest?: CreateObjectCategoriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateObjectCategories(id, createObjectCategoriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjectCategoriesApi.updateObjectCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObjectCategoriesApi - factory interface
 */
export const ObjectCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObjectCategoriesApiFp(configuration)
    return {
        /**
         * Create a new object category
         * @summary Create a new object category
         * @param {ObjectCategoriesApiCreateObjectCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObjectCategories(requestParameters: ObjectCategoriesApiCreateObjectCategoriesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ObjectCategory> {
            return localVarFp.createObjectCategories(requestParameters.createObjectCategoriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a object category
         * @param {ObjectCategoriesApiDeleteObjectCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectCategories(requestParameters: ObjectCategoriesApiDeleteObjectCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteObjectCategories(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific object category
         * @summary Retrieve a specific object category
         * @param {ObjectCategoriesApiGetObjectCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectCategories(requestParameters: ObjectCategoriesApiGetObjectCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObjectCategory> {
            return localVarFp.getObjectCategories(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of object categories  - Requires: `API Tier 1`
         * @summary List object categories
         * @param {ObjectCategoriesApiListObjectCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjectCategories(requestParameters: ObjectCategoriesApiListObjectCategoriesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListObjectCategories200Response> {
            return localVarFp.listObjectCategories(requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Updated a specific object category
         * @summary Update a object category
         * @param {ObjectCategoriesApiUpdateObjectCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectCategories(requestParameters: ObjectCategoriesApiUpdateObjectCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObjectCategory> {
            return localVarFp.updateObjectCategories(requestParameters.id, requestParameters.createObjectCategoriesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createObjectCategories operation in ObjectCategoriesApi.
 */
export interface ObjectCategoriesApiCreateObjectCategoriesRequest {
    readonly createObjectCategoriesRequest?: CreateObjectCategoriesRequest
}

/**
 * Request parameters for deleteObjectCategories operation in ObjectCategoriesApi.
 */
export interface ObjectCategoriesApiDeleteObjectCategoriesRequest {
    readonly id: string
}

/**
 * Request parameters for getObjectCategories operation in ObjectCategoriesApi.
 */
export interface ObjectCategoriesApiGetObjectCategoriesRequest {
    readonly id: string
}

/**
 * Request parameters for listObjectCategories operation in ObjectCategoriesApi.
 */
export interface ObjectCategoriesApiListObjectCategoriesRequest {
    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for updateObjectCategories operation in ObjectCategoriesApi.
 */
export interface ObjectCategoriesApiUpdateObjectCategoriesRequest {
    readonly id: string

    readonly createObjectCategoriesRequest?: CreateObjectCategoriesRequest
}

/**
 * ObjectCategoriesApi - object-oriented interface
 */
export class ObjectCategoriesApi extends BaseAPI {
    /**
     * Create a new object category
     * @summary Create a new object category
     * @param {ObjectCategoriesApiCreateObjectCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createObjectCategories(requestParameters: ObjectCategoriesApiCreateObjectCategoriesRequest = {}, options?: RawAxiosRequestConfig) {
        return ObjectCategoriesApiFp(this.configuration).createObjectCategories(requestParameters.createObjectCategoriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a object category
     * @param {ObjectCategoriesApiDeleteObjectCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteObjectCategories(requestParameters: ObjectCategoriesApiDeleteObjectCategoriesRequest, options?: RawAxiosRequestConfig) {
        return ObjectCategoriesApiFp(this.configuration).deleteObjectCategories(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific object category
     * @summary Retrieve a specific object category
     * @param {ObjectCategoriesApiGetObjectCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getObjectCategories(requestParameters: ObjectCategoriesApiGetObjectCategoriesRequest, options?: RawAxiosRequestConfig) {
        return ObjectCategoriesApiFp(this.configuration).getObjectCategories(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of object categories  - Requires: `API Tier 1`
     * @summary List object categories
     * @param {ObjectCategoriesApiListObjectCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listObjectCategories(requestParameters: ObjectCategoriesApiListObjectCategoriesRequest = {}, options?: RawAxiosRequestConfig) {
        return ObjectCategoriesApiFp(this.configuration).listObjectCategories(requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updated a specific object category
     * @summary Update a object category
     * @param {ObjectCategoriesApiUpdateObjectCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateObjectCategories(requestParameters: ObjectCategoriesApiUpdateObjectCategoriesRequest, options?: RawAxiosRequestConfig) {
        return ObjectCategoriesApiFp(this.configuration).updateObjectCategories(requestParameters.id, requestParameters.createObjectCategoriesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SupergroupsApi - axios parameter creator
 */
export const SupergroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific supergroup.
         * @summary Retrieve a specific supergroup
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupergroups: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSupergroups', 'id', id)
            const localVarPath = `/supergroups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["supergroups.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve supergroups matching the input parameters.  - Requires: `API Tier 1`  - Filterable fields: `app_owner_id`, `group_type`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroups
         * @param {string} [filter] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupergroups: async (filter?: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/supergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["supergroups.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve supergroup exclusion members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup exclusion members
         * @param {string} groupId 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupergroupsGroupIdExclusionMembers: async (groupId: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listSupergroupsGroupIdExclusionMembers', 'groupId', groupId)
            const localVarPath = `/supergroups/{group_id}/exclusion-members`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["supergroups.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve supergroup inclusion members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup inclusion members
         * @param {string} groupId 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupergroupsGroupIdInclusionMembers: async (groupId: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listSupergroupsGroupIdInclusionMembers', 'groupId', groupId)
            const localVarPath = `/supergroups/{group_id}/inclusion-members`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["supergroups.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve supergroup members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup members
         * @param {string} groupId 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupergroupsGroupIdMembers: async (groupId: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listSupergroupsGroupIdMembers', 'groupId', groupId)
            const localVarPath = `/supergroups/{group_id}/members`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["supergroups.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the list of supergroup exclusion members.
         * @summary Update supergroup exclusion members
         * @param {string} groupId 
         * @param {UpdateSupergroupsGroupIdInclusionMembersRequest} [updateSupergroupsGroupIdInclusionMembersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupergroupsGroupIdExclusionMembers: async (groupId: string, updateSupergroupsGroupIdInclusionMembersRequest?: UpdateSupergroupsGroupIdInclusionMembersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateSupergroupsGroupIdExclusionMembers', 'groupId', groupId)
            const localVarPath = `/supergroups/{group_id}/exclusion-members`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["supergroups.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSupergroupsGroupIdInclusionMembersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the list of supergroup inclusion members.
         * @summary Update supergroup inclusion members
         * @param {string} groupId 
         * @param {UpdateSupergroupsGroupIdInclusionMembersRequest} [updateSupergroupsGroupIdInclusionMembersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupergroupsGroupIdInclusionMembers: async (groupId: string, updateSupergroupsGroupIdInclusionMembersRequest?: UpdateSupergroupsGroupIdInclusionMembersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateSupergroupsGroupIdInclusionMembers', 'groupId', groupId)
            const localVarPath = `/supergroups/{group_id}/inclusion-members`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["supergroups.read-write"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSupergroupsGroupIdInclusionMembersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupergroupsApi - functional programming interface
 */
export const SupergroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupergroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific supergroup.
         * @summary Retrieve a specific supergroup
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupergroups(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSupergroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupergroups(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupergroupsApi.getSupergroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve supergroups matching the input parameters.  - Requires: `API Tier 1`  - Filterable fields: `app_owner_id`, `group_type`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroups
         * @param {string} [filter] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupergroups(filter?: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSupergroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupergroups(filter, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupergroupsApi.listSupergroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve supergroup exclusion members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup exclusion members
         * @param {string} groupId 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupergroupsGroupIdExclusionMembers(groupId: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSupergroupsGroupIdMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupergroupsGroupIdExclusionMembers(groupId, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupergroupsApi.listSupergroupsGroupIdExclusionMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve supergroup inclusion members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup inclusion members
         * @param {string} groupId 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupergroupsGroupIdInclusionMembers(groupId: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSupergroupsGroupIdMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupergroupsGroupIdInclusionMembers(groupId, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupergroupsApi.listSupergroupsGroupIdInclusionMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve supergroup members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup members
         * @param {string} groupId 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupergroupsGroupIdMembers(groupId: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSupergroupsGroupIdMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupergroupsGroupIdMembers(groupId, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupergroupsApi.listSupergroupsGroupIdMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the list of supergroup exclusion members.
         * @summary Update supergroup exclusion members
         * @param {string} groupId 
         * @param {UpdateSupergroupsGroupIdInclusionMembersRequest} [updateSupergroupsGroupIdInclusionMembersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupergroupsGroupIdExclusionMembers(groupId: string, updateSupergroupsGroupIdInclusionMembersRequest?: UpdateSupergroupsGroupIdInclusionMembersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateSupergroupsGroupIdInclusionMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupergroupsGroupIdExclusionMembers(groupId, updateSupergroupsGroupIdInclusionMembersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupergroupsApi.updateSupergroupsGroupIdExclusionMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the list of supergroup inclusion members.
         * @summary Update supergroup inclusion members
         * @param {string} groupId 
         * @param {UpdateSupergroupsGroupIdInclusionMembersRequest} [updateSupergroupsGroupIdInclusionMembersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupergroupsGroupIdInclusionMembers(groupId: string, updateSupergroupsGroupIdInclusionMembersRequest?: UpdateSupergroupsGroupIdInclusionMembersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateSupergroupsGroupIdInclusionMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupergroupsGroupIdInclusionMembers(groupId, updateSupergroupsGroupIdInclusionMembersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupergroupsApi.updateSupergroupsGroupIdInclusionMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SupergroupsApi - factory interface
 */
export const SupergroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupergroupsApiFp(configuration)
    return {
        /**
         * Retrieve a specific supergroup.
         * @summary Retrieve a specific supergroup
         * @param {SupergroupsApiGetSupergroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupergroups(requestParameters: SupergroupsApiGetSupergroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSupergroups200Response> {
            return localVarFp.getSupergroups(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve supergroups matching the input parameters.  - Requires: `API Tier 1`  - Filterable fields: `app_owner_id`, `group_type`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroups
         * @param {SupergroupsApiListSupergroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupergroups(requestParameters: SupergroupsApiListSupergroupsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListSupergroups200Response> {
            return localVarFp.listSupergroups(requestParameters.filter, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve supergroup exclusion members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup exclusion members
         * @param {SupergroupsApiListSupergroupsGroupIdExclusionMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupergroupsGroupIdExclusionMembers(requestParameters: SupergroupsApiListSupergroupsGroupIdExclusionMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListSupergroupsGroupIdMembers200Response> {
            return localVarFp.listSupergroupsGroupIdExclusionMembers(requestParameters.groupId, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve supergroup inclusion members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup inclusion members
         * @param {SupergroupsApiListSupergroupsGroupIdInclusionMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupergroupsGroupIdInclusionMembers(requestParameters: SupergroupsApiListSupergroupsGroupIdInclusionMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListSupergroupsGroupIdMembers200Response> {
            return localVarFp.listSupergroupsGroupIdInclusionMembers(requestParameters.groupId, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve supergroup members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List supergroup members
         * @param {SupergroupsApiListSupergroupsGroupIdMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupergroupsGroupIdMembers(requestParameters: SupergroupsApiListSupergroupsGroupIdMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListSupergroupsGroupIdMembers200Response> {
            return localVarFp.listSupergroupsGroupIdMembers(requestParameters.groupId, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the list of supergroup exclusion members.
         * @summary Update supergroup exclusion members
         * @param {SupergroupsApiUpdateSupergroupsGroupIdExclusionMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupergroupsGroupIdExclusionMembers(requestParameters: SupergroupsApiUpdateSupergroupsGroupIdExclusionMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateSupergroupsGroupIdInclusionMembers200Response> {
            return localVarFp.updateSupergroupsGroupIdExclusionMembers(requestParameters.groupId, requestParameters.updateSupergroupsGroupIdInclusionMembersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the list of supergroup inclusion members.
         * @summary Update supergroup inclusion members
         * @param {SupergroupsApiUpdateSupergroupsGroupIdInclusionMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupergroupsGroupIdInclusionMembers(requestParameters: SupergroupsApiUpdateSupergroupsGroupIdInclusionMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateSupergroupsGroupIdInclusionMembers200Response> {
            return localVarFp.updateSupergroupsGroupIdInclusionMembers(requestParameters.groupId, requestParameters.updateSupergroupsGroupIdInclusionMembersRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSupergroups operation in SupergroupsApi.
 */
export interface SupergroupsApiGetSupergroupsRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string
}

/**
 * Request parameters for listSupergroups operation in SupergroupsApi.
 */
export interface SupergroupsApiListSupergroupsRequest {
    readonly filter?: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for listSupergroupsGroupIdExclusionMembers operation in SupergroupsApi.
 */
export interface SupergroupsApiListSupergroupsGroupIdExclusionMembersRequest {
    readonly groupId: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for listSupergroupsGroupIdInclusionMembers operation in SupergroupsApi.
 */
export interface SupergroupsApiListSupergroupsGroupIdInclusionMembersRequest {
    readonly groupId: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for listSupergroupsGroupIdMembers operation in SupergroupsApi.
 */
export interface SupergroupsApiListSupergroupsGroupIdMembersRequest {
    readonly groupId: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * Request parameters for updateSupergroupsGroupIdExclusionMembers operation in SupergroupsApi.
 */
export interface SupergroupsApiUpdateSupergroupsGroupIdExclusionMembersRequest {
    readonly groupId: string

    readonly updateSupergroupsGroupIdInclusionMembersRequest?: UpdateSupergroupsGroupIdInclusionMembersRequest
}

/**
 * Request parameters for updateSupergroupsGroupIdInclusionMembers operation in SupergroupsApi.
 */
export interface SupergroupsApiUpdateSupergroupsGroupIdInclusionMembersRequest {
    readonly groupId: string

    readonly updateSupergroupsGroupIdInclusionMembersRequest?: UpdateSupergroupsGroupIdInclusionMembersRequest
}

/**
 * SupergroupsApi - object-oriented interface
 */
export class SupergroupsApi extends BaseAPI {
    /**
     * Retrieve a specific supergroup.
     * @summary Retrieve a specific supergroup
     * @param {SupergroupsApiGetSupergroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSupergroups(requestParameters: SupergroupsApiGetSupergroupsRequest, options?: RawAxiosRequestConfig) {
        return SupergroupsApiFp(this.configuration).getSupergroups(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve supergroups matching the input parameters.  - Requires: `API Tier 1`  - Filterable fields: `app_owner_id`, `group_type`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List supergroups
     * @param {SupergroupsApiListSupergroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSupergroups(requestParameters: SupergroupsApiListSupergroupsRequest = {}, options?: RawAxiosRequestConfig) {
        return SupergroupsApiFp(this.configuration).listSupergroups(requestParameters.filter, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve supergroup exclusion members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List supergroup exclusion members
     * @param {SupergroupsApiListSupergroupsGroupIdExclusionMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSupergroupsGroupIdExclusionMembers(requestParameters: SupergroupsApiListSupergroupsGroupIdExclusionMembersRequest, options?: RawAxiosRequestConfig) {
        return SupergroupsApiFp(this.configuration).listSupergroupsGroupIdExclusionMembers(requestParameters.groupId, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve supergroup inclusion members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List supergroup inclusion members
     * @param {SupergroupsApiListSupergroupsGroupIdInclusionMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSupergroupsGroupIdInclusionMembers(requestParameters: SupergroupsApiListSupergroupsGroupIdInclusionMembersRequest, options?: RawAxiosRequestConfig) {
        return SupergroupsApiFp(this.configuration).listSupergroupsGroupIdInclusionMembers(requestParameters.groupId, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve supergroup members matching the input parameters.  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List supergroup members
     * @param {SupergroupsApiListSupergroupsGroupIdMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSupergroupsGroupIdMembers(requestParameters: SupergroupsApiListSupergroupsGroupIdMembersRequest, options?: RawAxiosRequestConfig) {
        return SupergroupsApiFp(this.configuration).listSupergroupsGroupIdMembers(requestParameters.groupId, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the list of supergroup exclusion members.
     * @summary Update supergroup exclusion members
     * @param {SupergroupsApiUpdateSupergroupsGroupIdExclusionMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSupergroupsGroupIdExclusionMembers(requestParameters: SupergroupsApiUpdateSupergroupsGroupIdExclusionMembersRequest, options?: RawAxiosRequestConfig) {
        return SupergroupsApiFp(this.configuration).updateSupergroupsGroupIdExclusionMembers(requestParameters.groupId, requestParameters.updateSupergroupsGroupIdInclusionMembersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the list of supergroup inclusion members.
     * @summary Update supergroup inclusion members
     * @param {SupergroupsApiUpdateSupergroupsGroupIdInclusionMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSupergroupsGroupIdInclusionMembers(requestParameters: SupergroupsApiUpdateSupergroupsGroupIdInclusionMembersRequest, options?: RawAxiosRequestConfig) {
        return SupergroupsApiFp(this.configuration).updateSupergroupsGroupIdInclusionMembers(requestParameters.groupId, requestParameters.updateSupergroupsGroupIdInclusionMembersRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamsApi - axios parameter creator
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific team
         * @summary Retrieve a specific team
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams: async (id: string, expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeams', 'id', id)
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["teams.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of teams  - Requires: `API Tier 1`  - Expandable fields: `parent`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List teams
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams: async (expand?: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["teams.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific team
         * @summary Retrieve a specific team
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeams(id: string, expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(id, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.getTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of teams  - Requires: `API Tier 1`  - Expandable fields: `parent`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List teams
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeams(expand?: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTeams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeams(expand, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.listTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamsApi - factory interface
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * Retrieve a specific team
         * @summary Retrieve a specific team
         * @param {TeamsApiGetTeamsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(requestParameters: TeamsApiGetTeamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetTeams200Response> {
            return localVarFp.getTeams(requestParameters.id, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of teams  - Requires: `API Tier 1`  - Expandable fields: `parent`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List teams
         * @param {TeamsApiListTeamsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(requestParameters: TeamsApiListTeamsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListTeams200Response> {
            return localVarFp.listTeams(requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTeams operation in TeamsApi.
 */
export interface TeamsApiGetTeamsRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string

    readonly expand?: string
}

/**
 * Request parameters for listTeams operation in TeamsApi.
 */
export interface TeamsApiListTeamsRequest {
    readonly expand?: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * TeamsApi - object-oriented interface
 */
export class TeamsApi extends BaseAPI {
    /**
     * Retrieve a specific team
     * @summary Retrieve a specific team
     * @param {TeamsApiGetTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTeams(requestParameters: TeamsApiGetTeamsRequest, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeams(requestParameters.id, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of teams  - Requires: `API Tier 1`  - Expandable fields: `parent`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List teams
     * @param {TeamsApiListTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listTeams(requestParameters: TeamsApiListTeamsRequest = {}, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).listTeams(requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific user
         * @summary Retrieve a specific user
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsers', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["users.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of users  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List users
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["users.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific user
         * @summary Retrieve a specific user
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of users  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List users
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Retrieve a specific user
         * @summary Retrieve a specific user
         * @param {UsersApiGetUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(requestParameters: UsersApiGetUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetUsers200Response> {
            return localVarFp.getUsers(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of users  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List users
         * @param {UsersApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(requestParameters: UsersApiListUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListUsers200Response> {
            return localVarFp.listUsers(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUsers operation in UsersApi.
 */
export interface UsersApiGetUsersRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string
}

/**
 * Request parameters for listUsers operation in UsersApi.
 */
export interface UsersApiListUsersRequest {
    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Retrieve a specific user
     * @summary Retrieve a specific user
     * @param {UsersApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsers(requestParameters: UsersApiGetUsersRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of users  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List users
     * @param {UsersApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUsers(requestParameters: UsersApiListUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkLocationsApi - axios parameter creator
 */
export const WorkLocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific work location
         * @summary Retrieve a specific work location
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkLocations: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkLocations', 'id', id)
            const localVarPath = `/work-locations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["work-locations.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of work locations  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List work locations
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkLocations: async (orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["work-locations.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkLocationsApi - functional programming interface
 */
export const WorkLocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkLocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific work location
         * @summary Retrieve a specific work location
         * @param {string} id ID of the resource to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkLocations(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWorkLocations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkLocations(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkLocationsApi.getWorkLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of work locations  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List work locations
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkLocations(orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWorkLocations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkLocations(orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkLocationsApi.listWorkLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkLocationsApi - factory interface
 */
export const WorkLocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkLocationsApiFp(configuration)
    return {
        /**
         * Retrieve a specific work location
         * @summary Retrieve a specific work location
         * @param {WorkLocationsApiGetWorkLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkLocations(requestParameters: WorkLocationsApiGetWorkLocationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetWorkLocations200Response> {
            return localVarFp.getWorkLocations(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of work locations  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List work locations
         * @param {WorkLocationsApiListWorkLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkLocations(requestParameters: WorkLocationsApiListWorkLocationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListWorkLocations200Response> {
            return localVarFp.listWorkLocations(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getWorkLocations operation in WorkLocationsApi.
 */
export interface WorkLocationsApiGetWorkLocationsRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string
}

/**
 * Request parameters for listWorkLocations operation in WorkLocationsApi.
 */
export interface WorkLocationsApiListWorkLocationsRequest {
    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * WorkLocationsApi - object-oriented interface
 */
export class WorkLocationsApi extends BaseAPI {
    /**
     * Retrieve a specific work location
     * @summary Retrieve a specific work location
     * @param {WorkLocationsApiGetWorkLocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWorkLocations(requestParameters: WorkLocationsApiGetWorkLocationsRequest, options?: RawAxiosRequestConfig) {
        return WorkLocationsApiFp(this.configuration).getWorkLocations(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of work locations  - Requires: `API Tier 1`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List work locations
     * @param {WorkLocationsApiListWorkLocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWorkLocations(requestParameters: WorkLocationsApiListWorkLocationsRequest = {}, options?: RawAxiosRequestConfig) {
        return WorkLocationsApiFp(this.configuration).listWorkLocations(requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkersApi - axios parameter creator
 */
export const WorkersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific worker
         * @summary Retrieve a specific worker
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkers: async (id: string, expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkers', 'id', id)
            const localVarPath = `/workers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["workers.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A List of workers  - Requires: `API Tier 1`  - Filterable fields: `status`, `work_email`, `user_id`, `created_at`, `updated_at`  - Expandable fields: `user`, `manager`, `legal_entity`, `employment_type`, `compensation`, `department`, `teams`, `level`, `custom_fields`, `business_partners`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List workers
         * @param {string} [filter] 
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkers: async (filter?: string, expand?: string, orderBy?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Production required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Production", ["workers.read"], configuration)

            // authentication BearerTokenProduction required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkersApi - functional programming interface
 */
export const WorkersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific worker
         * @summary Retrieve a specific worker
         * @param {string} id ID of the resource to return
         * @param {string} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkers(id: string, expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWorkers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkers(id, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkersApi.getWorkers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A List of workers  - Requires: `API Tier 1`  - Filterable fields: `status`, `work_email`, `user_id`, `created_at`, `updated_at`  - Expandable fields: `user`, `manager`, `legal_entity`, `employment_type`, `compensation`, `department`, `teams`, `level`, `custom_fields`, `business_partners`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List workers
         * @param {string} [filter] 
         * @param {string} [expand] 
         * @param {string} [orderBy] 
         * @param {number} [limit] Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
         * @param {string} [cursor] Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkers(filter?: string, expand?: string, orderBy?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWorkers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkers(filter, expand, orderBy, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkersApi.listWorkers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkersApi - factory interface
 */
export const WorkersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkersApiFp(configuration)
    return {
        /**
         * Retrieve a specific worker
         * @summary Retrieve a specific worker
         * @param {WorkersApiGetWorkersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkers(requestParameters: WorkersApiGetWorkersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetWorkers200Response> {
            return localVarFp.getWorkers(requestParameters.id, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * A List of workers  - Requires: `API Tier 1`  - Filterable fields: `status`, `work_email`, `user_id`, `created_at`, `updated_at`  - Expandable fields: `user`, `manager`, `legal_entity`, `employment_type`, `compensation`, `department`, `teams`, `level`, `custom_fields`, `business_partners`  - Sortable fields: `id`, `created_at`, `updated_at`
         * @summary List workers
         * @param {WorkersApiListWorkersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkers(requestParameters: WorkersApiListWorkersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListWorkers200Response> {
            return localVarFp.listWorkers(requestParameters.filter, requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getWorkers operation in WorkersApi.
 */
export interface WorkersApiGetWorkersRequest {
    /**
     * ID of the resource to return
     */
    readonly id: string

    readonly expand?: string
}

/**
 * Request parameters for listWorkers operation in WorkersApi.
 */
export interface WorkersApiListWorkersRequest {
    readonly filter?: string

    readonly expand?: string

    readonly orderBy?: string

    /**
     * Maximum number of results to return on this page (default 50, typical max 100). If higher than the endpoint maximum, a 400 error is returned.
     */
    readonly limit?: number

    /**
     * Opaque cursor from a prior response\&#39;s next_link. Omit to start at the first page.
     */
    readonly cursor?: string
}

/**
 * WorkersApi - object-oriented interface
 */
export class WorkersApi extends BaseAPI {
    /**
     * Retrieve a specific worker
     * @summary Retrieve a specific worker
     * @param {WorkersApiGetWorkersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWorkers(requestParameters: WorkersApiGetWorkersRequest, options?: RawAxiosRequestConfig) {
        return WorkersApiFp(this.configuration).getWorkers(requestParameters.id, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A List of workers  - Requires: `API Tier 1`  - Filterable fields: `status`, `work_email`, `user_id`, `created_at`, `updated_at`  - Expandable fields: `user`, `manager`, `legal_entity`, `employment_type`, `compensation`, `department`, `teams`, `level`, `custom_fields`, `business_partners`  - Sortable fields: `id`, `created_at`, `updated_at`
     * @summary List workers
     * @param {WorkersApiListWorkersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWorkers(requestParameters: WorkersApiListWorkersRequest = {}, options?: RawAxiosRequestConfig) {
        return WorkersApiFp(this.configuration).listWorkers(requestParameters.filter, requestParameters.expand, requestParameters.orderBy, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



